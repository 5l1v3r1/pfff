(* Yoann Padioleau
 *
 * Copyright (C) 2010 Facebook
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 * 
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)

open Common
open Ocaml
open Ast_js

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(* 
 * The code below is mostly generated by 
 *   $ ocamltarzan -choice map ~/pfff/lang_js/parsing/ast_js.ml 
 * and adjusted to have visitor hooks.
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* hooks *)
type visitor_in = {
  kexpr: expr vin;
  kst: st vin;
  ktoplevel: toplevel vin;
  kany: any vin;
  
  kinfo: tok vin;
  kname: name vin;
}
  and 'a vin = ('a  -> 'a) * visitor_out -> 'a  -> 'a
and visitor_out = any -> any

let call_continuation = (fun (k, _) x -> k x)

let default_visitor = { 
  kexpr = call_continuation;
  kst = call_continuation;
  ktoplevel = call_continuation;
  kany = call_continuation;
  kinfo = call_continuation;
  kname = call_continuation;
}

(*****************************************************************************)
(* Main code *)
(*****************************************************************************)

module Type_js = struct
    let map_jstype x = x
end


let (mk_visitor: visitor_in -> visitor_out) = fun vin ->

(* start of auto generation *)

let rec map_info v = 
  (*Parse_info.map_info *)
  let rec k x = 
    x
  in
  vin.kinfo (k, map_any) v

(* The "'a." (forall) type annotation below requires ocaml 3.12. It's to
 * have polymorphic recursion.
 *)

and map_tok v = map_info v
and map_wrap: 'a. ('a -> 'a) -> 'a wrap -> 'a wrap = fun _of_a (v1, v2) ->
  let v1 = _of_a v1 and v2 = map_info v2 in (v1, v2)
and map_paren: 'a. ('a -> 'a) -> 'a paren -> 'a paren = fun _of_a (v1, v2, v3)->
  let v1 = map_tok v1 and v2 = _of_a v2 and v3 = map_tok v3 in (v1, v2, v3)
and map_brace: 'a. ('a -> 'a) -> 'a brace -> 'a brace = 
 fun _of_a (v1, v2, v3) ->
  let v1 = map_tok v1 and v2 = _of_a v2 and v3 = map_tok v3 in (v1, v2, v3)
and map_bracket: 'a. ('a -> 'a) -> 'a brace -> 'a brace = 
 fun  _of_a (v1, v2, v3) ->
  let v1 = map_tok v1 and v2 = _of_a v2 and v3 = map_tok v3 in (v1, v2, v3)
and map_comma_list: 'a. ('a -> 'a) -> 'a comma_list -> 'a comma_list = 
 fun  _of_a -> map_of_list (map_of_either _of_a map_tok)

and map_sc v = map_of_option map_tok v
  
and map_name x =
  let rec k v = map_wrap map_of_string v in
  vin.kname (k, map_any) x
  
and map_expr x =
  let k x =
    match x with
  | L v1 -> let v1 = map_litteral v1 in L ((v1))
  | V v1 -> let v1 = map_name v1 in V ((v1))
  | This v1 -> let v1 = map_tok v1 in This ((v1))
  | U ((v1, v2)) ->
      let v1 = map_wrap map_unop v1 and v2 = map_expr v2 in U ((v1, v2))
  | B ((v1, v2, v3)) ->
      let v1 = map_expr v1
      and v2 = map_wrap map_binop v2
      and v3 = map_expr v3
      in B ((v1, v2, v3))
  | Bracket ((v1, v2)) ->
      let v1 = map_expr v1
      and v2 = map_bracket map_expr v2
      in Bracket ((v1, v2))
  | Period ((v1, v2, v3)) ->
      let v1 = map_expr v1
      and v2 = map_tok v2
      and v3 = map_name v3
      in Period ((v1, v2, v3))
  | Object v1 ->
      let v1 = map_brace (map_comma_list map_field) v1 in Object ((v1))
  | Array v1 ->
      let v1 = map_bracket (map_comma_list map_expr) v1 in Array ((v1))
  | Apply ((v1, v2)) ->
      let v1 = map_expr v1
      and v2 = map_paren (map_comma_list map_expr) v2
      in Apply ((v1, v2))
  | Conditional ((v1, v2, v3, v4, v5)) ->
      let v1 = map_expr v1
      and v2 = map_tok v2
      and v3 = map_expr v3
      and v4 = map_tok v4
      and v5 = map_expr v5
      in Conditional ((v1, v2, v3, v4, v5))
  | Assign ((v1, v2, v3)) ->
      let v1 = map_expr v1
      and v2 = map_wrap map_assignment_operator v2
      and v3 = map_expr v3
      in Assign ((v1, v2, v3))
  | Seq ((v1, v2, v3)) ->
      let v1 = map_expr v1
      and v2 = map_tok v2
      and v3 = map_expr v3
      in Seq ((v1, v2, v3))
  | Function v1 -> let v1 = map_func_decl v1 in Function ((v1))
  | Extra v1 -> let v1 = map_extra v1 in Extra ((v1))
  | Paren v1 -> let v1 = map_paren map_expr v1 in Paren ((v1))
  in
  vin.kexpr (k, map_any) x

and map_extra = function | DanglingComma -> DanglingComma
and map_litteral =
  function
  | Bool v1 -> let v1 = map_wrap map_of_bool v1 in Bool ((v1))
  | Num v1 -> let v1 = map_wrap map_of_string v1 in Num ((v1))
  | String v1 -> let v1 = map_wrap map_of_string v1 in String ((v1))
  | Regexp v1 -> let v1 = map_wrap map_of_string v1 in Regexp ((v1))
  | Null v1 -> let v1 = map_tok v1 in Null ((v1))
  | Undefined -> Undefined
and map_unop =
  function
  | U_new -> U_new
  | U_delete -> U_delete
  | U_void -> U_void
  | U_typeof -> U_typeof
  | U_bitnot -> U_bitnot
  | U_pre_increment -> U_pre_increment
  | U_pre_decrement -> U_pre_decrement
  | U_post_increment -> U_post_increment
  | U_post_decrement -> U_post_decrement
  | U_plus -> U_plus
  | U_minus -> U_minus
  | U_not -> U_not
and map_binop =
  function
  | B_instanceof -> B_instanceof
  | B_in -> B_in
  | B_mul -> B_mul
  | B_div -> B_div
  | B_mod -> B_mod
  | B_add -> B_add
  | B_sub -> B_sub
  | B_le -> B_le
  | B_ge -> B_ge
  | B_lt -> B_lt
  | B_gt -> B_gt
  | B_lsr -> B_lsr
  | B_asr -> B_asr
  | B_lsl -> B_lsl
  | B_equal -> B_equal
  | B_notequal -> B_notequal
  | B_physequal -> B_physequal
  | B_physnotequal -> B_physnotequal
  | B_bitand -> B_bitand
  | B_bitor -> B_bitor
  | B_bitxor -> B_bitxor
  | B_and -> B_and
  | B_or -> B_or
and map_property_name =
  function
  | PN_String v1 -> let v1 = map_name v1 in PN_String ((v1))
  | PN_Num v1 -> let v1 = map_wrap map_of_string v1 in PN_Num ((v1))
  | PN_Empty -> PN_Empty
and map_assignment_operator =
  function
  | A_eq -> A_eq
  | A_mul -> A_mul
  | A_div -> A_div
  | A_mod -> A_mod
  | A_add -> A_add
  | A_sub -> A_sub
  | A_lsl -> A_lsl
  | A_lsr -> A_lsr
  | A_asr -> A_asr
  | A_and -> A_and
  | A_xor -> A_xor
  | A_or -> A_or
and map_field (v1, v2, v3) =
  let v1 = map_property_name v1
  and v2 = map_tok v2
  and v3 = map_expr v3
  in (v1, v2, v3)
and map_st x =
 let rec k =
  function
  | Variable ((v1, v2, v3)) ->
      let v1 = map_tok v1
      and v2 = map_comma_list map_variable_declaration v2
      and v3 = map_sc v3
      in Variable ((v1, v2, v3))
  | Const ((v1, v2, v3)) ->
      let v1 = map_tok v1
      and v2 = map_comma_list map_variable_declaration v2
      and v3 = map_sc v3
      in Const ((v1, v2, v3))
  | Block v1 ->
      let v1 = map_brace (map_of_list map_toplevel) v1 in Block ((v1))
  | Nop v1 -> let v1 = map_sc v1 in Nop ((v1))
  | ExprStmt ((v1, v2)) ->
      let v1 = map_expr v1 and v2 = map_sc v2 in ExprStmt ((v1, v2))
  | If ((v1, v2, v3, v4)) ->
      let v1 = map_tok v1
      and v2 = map_paren map_expr v2
      and v3 = map_st v3
      and v4 =
        map_of_option
          (fun (v1, v2) -> let v1 = map_tok v1 and v2 = map_st v2 in (v1, v2))
          v4
      in If ((v1, v2, v3, v4))
  | Do ((v1, v2, v3, v4, v5)) ->
      let v1 = map_tok v1
      and v2 = map_st v2
      and v3 = map_tok v3
      and v4 = map_paren map_expr v4
      and v5 = map_sc v5
      in Do ((v1, v2, v3, v4, v5))
  | While ((v1, v2, v3)) ->
      let v1 = map_tok v1
      and v2 = map_paren map_expr v2
      and v3 = map_st v3
      in While ((v1, v2, v3))
  | For ((v1, v2, v3, v4, v5, v6, v7, v8, v9)) ->
      let v1 = map_tok v1
      and v2 = map_tok v2
      and v3 = map_of_option map_lhs_or_var v3
      and v4 = map_tok v4
      and v5 = map_of_option map_expr v5
      and v6 = map_tok v6
      and v7 = map_of_option map_expr v7
      and v8 = map_tok v8
      and v9 = map_st v9
      in For ((v1, v2, v3, v4, v5, v6, v7, v8, v9))
  | ForIn ((v1, v2, v3, v4, v5, v6, v7)) ->
      let v1 = map_tok v1
      and v2 = map_tok v2
      and v3 = map_lhs_or_var v3
      and v4 = map_tok v4
      and v5 = map_expr v5
      and v6 = map_tok v6
      and v7 = map_st v7
      in ForIn ((v1, v2, v3, v4, v5, v6, v7))
  | Switch ((v1, v2, v3)) ->
      let v1 = map_tok v1
      and v2 = map_paren map_expr v2
      and v3 = map_brace (map_of_list map_case_clause) v3
      in Switch ((v1, v2, v3))
  | Continue ((v1, v2, v3)) ->
      let v1 = map_tok v1
      and v2 = map_of_option map_label v2
      and v3 = map_sc v3
      in Continue ((v1, v2, v3))
  | Break ((v1, v2, v3)) ->
      let v1 = map_tok v1
      and v2 = map_of_option map_label v2
      and v3 = map_sc v3
      in Break ((v1, v2, v3))
  | Return ((v1, v2, v3)) ->
      let v1 = map_tok v1
      and v2 = map_of_option map_expr v2
      and v3 = map_sc v3
      in Return ((v1, v2, v3))
  | With ((v1, v2, v3)) ->
      let v1 = map_tok v1
      and v2 = map_paren map_expr v2
      and v3 = map_st v3
      in With ((v1, v2, v3))
  | Labeled ((v1, v2, v3)) ->
      let v1 = map_label v1
      and v2 = map_tok v2
      and v3 = map_st v3
      in Labeled ((v1, v2, v3))
  | Throw ((v1, v2, v3)) ->
      let v1 = map_tok v1
      and v2 = map_expr v2
      and v3 = map_sc v3
      in Throw ((v1, v2, v3))
  | Try ((v1, v2, v3, v4)) ->
      let v1 = map_tok v1
      and v2 = map_st v2
      and v3 =
        map_of_option
          (fun (v1, v2, v3) ->
             let v1 = map_tok v1
             and v2 = map_paren map_arg v2
             and v3 = map_st v3
             in (v1, v2, v3))
          v3
      and v4 =
        map_of_option
          (fun (v1, v2) -> let v1 = map_tok v1 and v2 = map_st v2 in (v1, v2))
          v4
      in Try ((v1, v2, v3, v4))
 in
 vin.kst (k, map_any) x

and map_label v = map_wrap map_of_string v
and map_lhs_or_var =
  function
  | LHS v1 -> let v1 = map_expr v1 in LHS ((v1))
  | Vars ((v1, v2)) ->
      let v1 = map_tok v1
      and v2 = map_comma_list map_variable_declaration v2
      in Vars ((v1, v2))
and map_case_clause =
  function
  | Default ((v1, v2, v3)) ->
      let v1 = map_tok v1
      and v2 = map_tok v2
      and v3 = map_of_list map_toplevel v3
      in Default ((v1, v2, v3))
  | Case ((v1, v2, v3, v4)) ->
      let v1 = map_tok v1
      and v2 = map_expr v2
      and v3 = map_tok v3
      and v4 = map_of_list map_toplevel v4
      in Case ((v1, v2, v3, v4))
and map_arg v = map_wrap map_of_string v
and map_func_decl (v1, v2, v3, v4) =
  let v1 = map_tok v1
  and v2 = map_of_option map_name v2
  and v3 = map_paren (map_comma_list map_name) v3
  and v4 = map_brace (map_of_list map_toplevel) v4
  in (v1, v2, v3, v4)
and map_variable_declaration (v1, v2) =
  let v1 = map_name v1
  and v2 =
    map_of_option
      (fun (v1, v2) -> let v1 = map_tok v1 and v2 = map_expr v2 in (v1, v2))
      v2
  in (v1, v2)
and map_toplevel x =
  let rec k =
  function
  | St v1 -> let v1 = map_st v1 in St ((v1))
  | FunDecl v1 -> let v1 = map_func_decl v1 in FunDecl ((v1))
  | NotParsedCorrectly v1 ->
      let v1 = map_of_list map_info v1 in NotParsedCorrectly ((v1))
  | FinalDef v1 -> let v1 = map_info v1 in FinalDef ((v1))
  in
  vin.ktoplevel (k, map_any) x

and map_program v = map_of_list map_toplevel v

and map_any x =
  let rec k =
  function
  | Expr v1 -> let v1 = map_expr v1 in Expr ((v1))
  | Stmt v1 -> let v1 = map_st v1 in Stmt ((v1))
  | Func v1 -> let v1 = map_func_decl v1 in Func ((v1))
  | Toplevel v1 -> let v1 = map_toplevel v1 in Toplevel ((v1))
  | Program v1 -> let v1 = map_program v1 in Program ((v1))
  in
  vin.kany (k, map_any) x

in
map_any
