%-------------------------------------------------------------------------------
% Prelude
%-------------------------------------------------------------------------------

% This file implements a basic context-insensitive pointer analysis.
% Its outputs are the following relations:
%
%   point_to(V, M)           - variable 'V' may point to abstract memory loc 'M'
%   field_point_to(FIELD, M) - qualified field  may point to abstract memory loc 'M'
%   dyncall(INVOKE, TARGET)  - invocation site 'invoke' calls function 'target'

% Based upon: Java context-insensitive inclusion-based pointer analysis
% by John Whaley

%-------------------------------------------------------------------------------
% Relations
%-------------------------------------------------------------------------------

% Abstract memory location (also called heap objects):
% - each globals, functions, constants
% - each malloc (context insensitively). will do sensitively later for 
%   malloc wrappers or maybe each malloc with certain type. (e.g. any Proc).
% - each locals (context insensitively first), when their address is taken
% - each fields (field-based, see sep08.pdf)
% - array aggregation

% Invocation: line in the file

%assign(dest:V, source:V) input
%assign_address (v:V, h:H) input
%assign_deref(dest:V, source:V) input
%
%... assign_field(field:F, source:V) input
%...


%-------------------------------------------------------------------------------
% Rules
%-------------------------------------------------------------------------------

% p = &x
point_to(P, X) :-
  assign_address(P, X).

% *q = w, given: q -> p, and w -> v => p now points to v
point_to(P, V) :-
  assign_deref(Q, W),
  point_to(W, V),
  point_to(Q, P).

% q = p
point_to(P,L) :-
        assign(P, Q),
        point_to(Q, L).
  
point_to(A,B)?
