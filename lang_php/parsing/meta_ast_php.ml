(* generated by ocamltarzan: ocamltarzan -vof ast_php.ml *)

open Common

open Ast_php

(* pad: few tweaks because of module limitations in ocamltarzan.
 *  
 * I inlined the vof_of_phptype here and vof_of_phpscope
 * (to avoid having multiple meta_of_xxx.ml files)
 *)
module Common = struct

let vof_either _of_a _of_b =
  function
  | Left v1 -> let v1 = _of_a v1 in Ocaml.VSum (("Left", [ v1 ]))
  | Right v1 -> let v1 = _of_b v1 in Ocaml.VSum (("Right", [ v1 ]))
end

module Type_php = struct
    let vof_phptype x = 
      Ocaml.VTODO ""
    let vof_phpfunction_type x = 
      Ocaml.VTODO ""
end
module Scope_php = struct
    let vof_phpscope x = 
      match x with
  | Scope_php.Global -> Ocaml.VSum (("Global", []))
  | Scope_php.Local -> Ocaml.VSum (("Local", []))
  | Scope_php.Param -> Ocaml.VSum (("Param", []))
  | Scope_php.Class -> Ocaml.VSum (("Class", []))
  | Scope_php.LocalExn -> Ocaml.VSum (("LocalExn", []))
  | Scope_php.LocalIterator -> Ocaml.VSum (("LocalIterator", []))
  | Scope_php.ListBinded -> Ocaml.VSum (("ListBinded", []))
  | Scope_php.NoScope -> Ocaml.VSum (("NoScope", []))

end

 
let vof_int = Ocaml.vof_int
let vof_unit = Ocaml.vof_unit
let vof_string = Ocaml.vof_string
let vof_list = Ocaml.vof_list
let vof_option = Ocaml.vof_option
let vof_ref = Ocaml.vof_ref

(* pad: generated code starts here *)


  
let rec vof_info { pinfo = v_pinfo; comments = v_comments; transfo = v_transfo } =
  let bnds = [] in
  let arg = vof_transformation v_transfo in
  let bnd = ("transfo", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_unit v_comments in
  let bnd = ("comments", arg) in
  let bnds = bnd :: bnds in
  let arg = Parse_info.vof_vtoken v_pinfo in
  let bnd = ("pinfo", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_tok v = vof_info v
and vof_wrap _of_a (v1, v2) =
  let v1 = _of_a v1 and v2 = vof_info v2 in Ocaml.VTuple [ v1; v2 ]
and vof_paren _of_a (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_brace _of_a (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_bracket _of_a (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]

and vof_comma_list _of_a xs = 
  Ocaml.vof_list (fun x -> Common.vof_either _of_a vof_info x) xs
and vof_transformation =
  function
  | NoTransfo -> Ocaml.VSum (("NoTransfo", []))
  | Remove -> Ocaml.VSum (("Remove", []))
  | AddBefore v1 -> let v1 = vof_add v1 in Ocaml.VSum (("AddBefore", [ v1 ]))
  | AddAfter v1 -> let v1 = vof_add v1 in Ocaml.VSum (("AddAfter", [ v1 ]))
  | Replace v1 -> let v1 = vof_add v1 in Ocaml.VSum (("Replace", [ v1 ]))
and vof_add =
  function
  | AddStr v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("AddStr", [ v1 ]))
  | AddNewlineAndIdent -> Ocaml.VSum (("AddNewlineAndIdent", []))
  
let rec vof_name =
  function
  | Name v1 ->
      let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("Name", [ v1 ]))
  | XhpName v1 ->
      let v1 = vof_wrap vof_xhp_tag v1 in Ocaml.VSum (("XhpName", [ v1 ]))
and vof_xhp_tag v = Ocaml.vof_list Ocaml.vof_string v
and vof_dname =
  function
  | DName v1 ->
      let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("DName", [ v1 ]))
and vof_qualifier =
  function
  | Qualifier ((v1, v2)) ->
      let v1 = vof_fully_qualified_class_name v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("Qualifier", [ v1; v2 ]))
  | Self ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("Self", [ v1; v2 ]))
  | Parent ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("Parent", [ v1; v2 ]))

and vof_fully_qualified_class_name v = vof_name v
  
let vof_ptype =
  function
  | BoolTy -> Ocaml.VSum (("BoolTy", []))
  | IntTy -> Ocaml.VSum (("IntTy", []))
  | DoubleTy -> Ocaml.VSum (("DoubleTy", []))
  | StringTy -> Ocaml.VSum (("StringTy", []))
  | ArrayTy -> Ocaml.VSum (("ArrayTy", []))
  | ObjectTy -> Ocaml.VSum (("ObjectTy", []))
  
let rec vof_expr (v1, v2) =
  let v1 = vof_exprbis v1 and v2 = vof_exp_info v2 in Ocaml.VTuple [ v1; v2 ]
and vof_exp_info { t = v_t } =
  let bnds = [] in
  let arg = Type_php.vof_phptype v_t in
  let bnd = ("t", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_exprbis =
  function
  | Lv v1 -> let v1 = vof_lvalue v1 in Ocaml.VSum (("Lv", [ v1 ]))
  | Sc v1 -> let v1 = vof_scalar v1 in Ocaml.VSum (("Sc", [ v1 ]))
  | Binary ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_wrap vof_binaryOp v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("Binary", [ v1; v2; v3 ]))
  | Unary ((v1, v2)) ->
      let v1 = vof_wrap vof_unaryOp v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Unary", [ v1; v2 ]))
  | Assign ((v1, v2, v3)) ->
      let v1 = vof_variable v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("Assign", [ v1; v2; v3 ]))
  | AssignOp ((v1, v2, v3)) ->
      let v1 = vof_variable v1
      and v2 = vof_wrap vof_assignOp v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("AssignOp", [ v1; v2; v3 ]))
  | Postfix ((v1, v2)) ->
      let v1 = vof_rw_variable v1
      and v2 = vof_wrap vof_fixOp v2
      in Ocaml.VSum (("Postfix", [ v1; v2 ]))
  | Infix ((v1, v2)) ->
      let v1 = vof_wrap vof_fixOp v1
      and v2 = vof_rw_variable v2
      in Ocaml.VSum (("Infix", [ v1; v2 ]))
  | CondExpr ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3
      and v4 = vof_tok v4
      and v5 = vof_expr v5
      in Ocaml.VSum (("CondExpr", [ v1; v2; v3; v4; v5 ]))
  | AssignList ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_list_assign) v2
      and v3 = vof_tok v3
      and v4 = vof_expr v4
      in Ocaml.VSum (("AssignList", [ v1; v2; v3; v4 ]))
  | ConsArray ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_array_pair) v2
      in Ocaml.VSum (("ConsArray", [ v1; v2 ]))
  | New ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_class_name_reference v2
      and v3 = vof_option (vof_paren (vof_comma_list vof_argument)) v3
      in Ocaml.VSum (("New", [ v1; v2; v3 ]))
  | Clone ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Clone", [ v1; v2 ]))
  | AssignRef ((v1, v2, v3, v4)) ->
      let v1 = vof_variable v1
      and v2 = vof_tok v2
      and v3 = vof_tok v3
      and v4 = vof_variable v4
      in Ocaml.VSum (("AssignRef", [ v1; v2; v3; v4 ]))
  | AssignNew ((v1, v2, v3, v4, v5, v6)) ->
      let v1 = vof_variable v1
      and v2 = vof_tok v2
      and v3 = vof_tok v3
      and v4 = vof_tok v4
      and v5 = vof_class_name_reference v5
      and v6 = vof_option (vof_paren (vof_comma_list vof_argument)) v6
      in Ocaml.VSum (("AssignNew", [ v1; v2; v3; v4; v5; v6 ]))
  | Cast ((v1, v2)) ->
      let v1 = vof_wrap vof_castOp v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Cast", [ v1; v2 ]))
  | CastUnset ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("CastUnset", [ v1; v2 ]))
  | InstanceOf ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_class_name_reference v3
      in Ocaml.VSum (("InstanceOf", [ v1; v2; v3 ]))
  | Eval ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      in Ocaml.VSum (("Eval", [ v1; v2 ]))
  | Lambda v1 ->
      let v1 = vof_lambda_def v1 in Ocaml.VSum (("Lambda", [ v1 ]))
  | Exit ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_option (vof_paren (vof_option vof_expr)) v2
      in Ocaml.VSum (("Exit", [ v1; v2 ]))
  | At ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("At", [ v1; v2 ]))
  | Print ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Print", [ v1; v2 ]))
  | BackQuote ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_list vof_encaps v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("BackQuote", [ v1; v2; v3 ]))
  | Include ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Include", [ v1; v2 ]))
  | IncludeOnce ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("IncludeOnce", [ v1; v2 ]))
  | Require ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Require", [ v1; v2 ]))
  | RequireOnce ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("RequireOnce", [ v1; v2 ]))
  | Empty ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_variable v2
      in Ocaml.VSum (("Empty", [ v1; v2 ]))
  | Isset ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_variable) v2
      in Ocaml.VSum (("Isset", [ v1; v2 ]))
  | XhpHtml v1 ->
      let v1 = vof_xhp_html v1 in Ocaml.VSum (("XhpHtml", [ v1 ]))
  | EDots v1 -> let v1 = vof_info v1 in Ocaml.VSum (("EDots", [ v1 ]))
  | ParenExpr v1 ->
      let v1 = vof_paren vof_expr v1 in Ocaml.VSum (("ParenExpr", [ v1 ]))
and vof_scalar =
  function
  | C v1 ->
      let v1 = vof_constant v1 in Ocaml.VSum (("C", [ v1 ]))
  | ClassConstant v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = vof_qualifier v1
             and v2 = vof_name v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("ClassConstant", [ v1 ]))
  | Guil ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_list vof_encaps v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Guil", [ v1; v2; v3 ]))
  | HereDoc ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_list vof_encaps v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("HereDoc", [ v1; v2; v3 ]))
and vof_constant =
  function
  | Int v1 -> let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("Int", [ v1 ]))
  | Double v1 ->
      let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("Double", [ v1 ]))
  | String v1 ->
      let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("String", [ v1 ]))
  | CName v1 -> let v1 = vof_name v1 in Ocaml.VSum (("CName", [ v1 ]))
  | PreProcess v1 ->
      let v1 = vof_wrap vof_cpp_directive v1
      in Ocaml.VSum (("PreProcess", [ v1 ]))
  | XdebugClass ((v1, v2)) ->
      let v1 = vof_name v1
      and v2 = Ocaml.vof_list vof_class_stmt v2
      in Ocaml.VSum (("XdebugClass", [ v1; v2 ]))
  | XdebugResource -> Ocaml.VSum (("XdebugResource", []))
and vof_cpp_directive =
  function
  | Line -> Ocaml.VSum (("Line", []))
  | File -> Ocaml.VSum (("File", []))
  | ClassC -> Ocaml.VSum (("ClassC", []))
  | MethodC -> Ocaml.VSum (("MethodC", []))
  | FunctionC -> Ocaml.VSum (("FunctionC", []))
and vof_encaps =
  function
  | EncapsString v1 ->
      let v1 = vof_wrap vof_string v1
      in Ocaml.VSum (("EncapsString", [ v1 ]))
  | EncapsVar v1 ->
      let v1 = vof_variable v1 in Ocaml.VSum (("EncapsVar", [ v1 ]))
  | EncapsCurly ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_variable v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("EncapsCurly", [ v1; v2; v3 ]))
  | EncapsDollarCurly ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_variable v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("EncapsDollarCurly", [ v1; v2; v3 ]))
  | EncapsExpr ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("EncapsExpr", [ v1; v2; v3 ]))
and vof_fixOp =
  function
  | Dec -> Ocaml.VSum (("Dec", []))
  | Inc -> Ocaml.VSum (("Inc", []))
and vof_binaryOp =
  function
  | Arith v1 -> let v1 = vof_arithOp v1 in Ocaml.VSum (("Arith", [ v1 ]))
  | Logical v1 ->
      let v1 = vof_logicalOp v1 in Ocaml.VSum (("Logical", [ v1 ]))
  | BinaryConcat -> Ocaml.VSum (("BinaryConcat", []))
and vof_arithOp =
  function
  | Plus -> Ocaml.VSum (("Plus", []))
  | Minus -> Ocaml.VSum (("Minus", []))
  | Mul -> Ocaml.VSum (("Mul", []))
  | Div -> Ocaml.VSum (("Div", []))
  | Mod -> Ocaml.VSum (("Mod", []))
  | DecLeft -> Ocaml.VSum (("DecLeft", []))
  | DecRight -> Ocaml.VSum (("DecRight", []))
  | And -> Ocaml.VSum (("And", []))
  | Or -> Ocaml.VSum (("Or", []))
  | Xor -> Ocaml.VSum (("Xor", []))
and vof_logicalOp =
  function
  | Inf -> Ocaml.VSum (("Inf", []))
  | Sup -> Ocaml.VSum (("Sup", []))
  | InfEq -> Ocaml.VSum (("InfEq", []))
  | SupEq -> Ocaml.VSum (("SupEq", []))
  | Eq -> Ocaml.VSum (("Eq", []))
  | NotEq -> Ocaml.VSum (("NotEq", []))
  | Identical -> Ocaml.VSum (("Identical", []))
  | NotIdentical -> Ocaml.VSum (("NotIdentical", []))
  | AndLog -> Ocaml.VSum (("AndLog", []))
  | OrLog -> Ocaml.VSum (("OrLog", []))
  | XorLog -> Ocaml.VSum (("XorLog", []))
  | AndBool -> Ocaml.VSum (("AndBool", []))
  | OrBool -> Ocaml.VSum (("OrBool", []))
and vof_assignOp =
  function
  | AssignOpArith v1 ->
      let v1 = vof_arithOp v1 in Ocaml.VSum (("AssignOpArith", [ v1 ]))
  | AssignConcat -> Ocaml.VSum (("AssignConcat", []))
and vof_unaryOp =
  function
  | UnPlus -> Ocaml.VSum (("UnPlus", []))
  | UnMinus -> Ocaml.VSum (("UnMinus", []))
  | UnBang -> Ocaml.VSum (("UnBang", []))
  | UnTilde -> Ocaml.VSum (("UnTilde", []))
and vof_castOp v = vof_ptype v
and vof_list_assign =
  function
  | ListVar v1 ->
      let v1 = vof_variable v1 in Ocaml.VSum (("ListVar", [ v1 ]))
  | ListList ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_list_assign) v2
      in Ocaml.VSum (("ListList", [ v1; v2 ]))
  | ListEmpty -> Ocaml.VSum (("ListEmpty", []))
and vof_array_pair =
  function
  | ArrayExpr v1 ->
      let v1 = vof_expr v1 in Ocaml.VSum (("ArrayExpr", [ v1 ]))
  | ArrayRef ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_variable v2
      in Ocaml.VSum (("ArrayRef", [ v1; v2 ]))
  | ArrayArrowExpr ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("ArrayArrowExpr", [ v1; v2; v3 ]))
  | ArrayArrowRef ((v1, v2, v3, v4)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      and v3 = vof_tok v3
      and v4 = vof_variable v4
      in Ocaml.VSum (("ArrayArrowRef", [ v1; v2; v3; v4 ]))
and vof_class_name_reference =
  function
  | ClassNameRefStatic v1 ->
      let v1 = vof_name v1 in Ocaml.VSum (("ClassNameRefStatic", [ v1 ]))
  | ClassNameRefDynamic v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = vof_variable v1
             and v2 = vof_list vof_obj_prop_access v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("ClassNameRefDynamic", [ v1 ]))
and vof_obj_prop_access (v1, v2) =
  let v1 = vof_tok v1 and v2 = vof_obj_property v2 in Ocaml.VTuple [ v1; v2 ]
and vof_xhp_html =
  function
  | Xhp ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_wrap vof_xhp_tag v1
      and v2 = Ocaml.vof_list vof_xhp_attribute v2
      and v3 = vof_tok v3
      and v4 = Ocaml.vof_list vof_xhp_body v4
      and v5 = vof_wrap (Ocaml.vof_option vof_xhp_tag) v5
      in Ocaml.VSum (("Xhp", [ v1; v2; v3; v4; v5 ]))
  | XhpSingleton ((v1, v2, v3)) ->
      let v1 = vof_wrap vof_xhp_tag v1
      and v2 = Ocaml.vof_list vof_xhp_attribute v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("XhpSingleton", [ v1; v2; v3 ]))
and vof_xhp_attribute (v1, v2, v3) =
  let v1 = vof_xhp_attr_name v1
  and v2 = vof_tok v2
  and v3 = vof_xhp_attr_value v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_xhp_attr_name v = vof_wrap Ocaml.vof_string v
and vof_xhp_attr_value =
  function
  | XhpAttrString ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = Ocaml.vof_list vof_encaps v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("XhpAttrString", [ v1; v2; v3 ]))
  | XhpAttrExpr v1 ->
      let v1 = vof_brace vof_expr v1 in Ocaml.VSum (("XhpAttrExpr", [ v1 ]))
and vof_xhp_body =
  function
  | XhpText v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("XhpText", [ v1 ]))
  | XhpExpr v1 ->
      let v1 = vof_brace vof_expr v1 in Ocaml.VSum (("XhpExpr", [ v1 ]))
  | XhpNested v1 ->
      let v1 = vof_xhp_html v1 in Ocaml.VSum (("XhpNested", [ v1 ]))
and vof_lvalue x = vof_variable x
and vof_variable (v1, v2) =
  let v1 = vof_variablebis v1
  and v2 = vof_var_info v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_var_info { tlval = v_tvar } =
  let bnds = [] in
  let arg = Type_php.vof_phptype v_tvar in
  let bnd = ("tvar", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_variablebis =
  function
  | Var ((v1, v2)) ->
      let v1 = vof_dname v1
      and v2 = vof_ref Scope_php.vof_phpscope v2
      in Ocaml.VSum (("Var", [ v1; v2 ]))
  | This v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("This", [ v1 ]))
  | VArrayAccess ((v1, v2)) ->
      let v1 = vof_variable v1
      and v2 = vof_bracket (vof_option vof_expr) v2
      in Ocaml.VSum (("VArrayAccess", [ v1; v2 ]))
  | VBrace ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_brace vof_expr v2
      in Ocaml.VSum (("VBrace", [ v1; v2 ]))
  | VBraceAccess ((v1, v2)) ->
      let v1 = vof_variable v1
      and v2 = vof_brace vof_expr v2
      in Ocaml.VSum (("VBraceAccess", [ v1; v2 ]))
  | Indirect ((v1, v2)) ->
      let v1 = vof_variable v1
      and v2 = vof_indirect v2
      in Ocaml.VSum (("Indirect", [ v1; v2 ]))
  | VQualifier ((v1, v2)) ->
      let v1 = vof_qualifier v1
      and v2 = vof_variable v2
      in Ocaml.VSum (("VQualifier", [ v1; v2 ]))
  | FunCallSimple ((v2, v3)) ->
      let v2 = vof_name v2
      and v3 = vof_paren (vof_comma_list vof_argument) v3
      in Ocaml.VSum (("FunCallSimple", [v2; v3 ]))
  | FunCallVar ((v1, v2, v3)) ->
      let v1 = vof_option vof_qualifier v1
      and v2 = vof_variable v2
      and v3 = vof_paren (vof_comma_list vof_argument) v3
      in Ocaml.VSum (("FunCallVar", [ v1; v2; v3 ]))
  | StaticMethodCallSimple ((v1, v2, v3)) ->
      let v1 = vof_qualifier v1
      and v2 = vof_name v2
      and v3 = vof_paren (vof_comma_list vof_argument) v3
      in Ocaml.VSum (("StaticMethodCallSimple", [ v1; v2; v3 ]))
  | MethodCallSimple ((v1, v2, v3, v4)) ->
      let v1 = vof_variable v1
      and v2 = vof_tok v2
      and v3 = vof_name v3
      and v4 = vof_paren (vof_comma_list vof_argument) v4
      in Ocaml.VSum (("MethodCallSimple", [ v1; v2; v3; v4 ]))
  | ObjAccessSimple ((v1, v2, v3)) ->
      let v1 = vof_variable v1
      and v2 = vof_tok v2
      and v3 = vof_name v3
      in Ocaml.VSum (("ObjAccessSimple", [ v1; v2; v3 ]))
  | ObjAccess ((v1, v2)) ->
      let v1 = vof_variable v1
      and v2 = vof_obj_access v2
      in Ocaml.VSum (("ObjAccess", [ v1; v2 ]))
and vof_indirect =
  function
  | Dollar v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("Dollar", [ v1 ]))
and vof_argument =
  function
  | Arg v1 -> let v1 = vof_expr v1 in Ocaml.VSum (("Arg", [ v1 ]))
  | ArgRef ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_w_variable v2
      in Ocaml.VSum (("ArgRef", [ v1; v2 ]))
and vof_obj_access (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = vof_obj_property v2
  and v3 = vof_option (vof_paren (vof_comma_list vof_argument)) v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_obj_property =
  function
  | ObjProp v1 -> let v1 = vof_obj_dim v1 in Ocaml.VSum (("ObjProp", [ v1 ]))
  | ObjPropVar v1 ->
      let v1 = vof_variable v1 in Ocaml.VSum (("ObjPropVar", [ v1 ]))
and vof_obj_dim =
  function
  | OName v1 -> let v1 = vof_name v1 in Ocaml.VSum (("OName", [ v1 ]))
  | OBrace v1 ->
      let v1 = vof_brace vof_expr v1 in Ocaml.VSum (("OBrace", [ v1 ]))
  | OArrayAccess ((v1, v2)) ->
      let v1 = vof_obj_dim v1
      and v2 = vof_bracket (vof_option vof_expr) v2
      in Ocaml.VSum (("OArrayAccess", [ v1; v2 ]))
  | OBraceAccess ((v1, v2)) ->
      let v1 = vof_obj_dim v1
      and v2 = vof_brace vof_expr v2
      in Ocaml.VSum (("OBraceAccess", [ v1; v2 ]))
and vof_rw_variable v = vof_variable v
and vof_r_variable v = vof_variable v
and vof_w_variable v = vof_variable v
  
and vof_stmt =
  function
  | ExprStmt ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("ExprStmt", [ v1; v2 ]))
  | EmptyStmt v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("EmptyStmt", [ v1 ]))
  | Block v1 ->
      let v1 = vof_brace (vof_list vof_stmt_and_def) v1
      in Ocaml.VSum (("Block", [ v1 ]))
  | If ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      and v3 = vof_stmt v3
      and v4 =
        vof_list
          (fun (v1, v2, v3) ->
             let v1 = vof_tok v1
             and v2 = vof_paren vof_expr v2
             and v3 = vof_stmt v3
             in Ocaml.VTuple [ v1; v2; v3 ])
          v4
      and v5 =
        vof_option
          (fun (v1, v2) ->
             let v1 = vof_tok v1
             and v2 = vof_stmt v2
             in Ocaml.VTuple [ v1; v2 ])
          v5
      in Ocaml.VSum (("If", [ v1; v2; v3; v4; v5 ]))
  | IfColon ((v1, v2, v3, v4, v5, v6, v7, v8)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      and v3 = vof_tok v3
      and v4 = vof_list vof_stmt_and_def v4
      and v5 = vof_list vof_new_elseif v5
      and v6 = vof_option vof_new_else v6
      and v7 = vof_tok v7
      and v8 = vof_tok v8
      in Ocaml.VSum (("IfColon", [ v1; v2; v3; v4; v5; v6; v7; v8 ]))
  | While ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      and v3 = vof_colon_stmt v3
      in Ocaml.VSum (("While", [ v1; v2; v3 ]))
  | Do ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_tok v1
      and v2 = vof_stmt v2
      and v3 = vof_tok v3
      and v4 = vof_paren vof_expr v4
      and v5 = vof_tok v5
      in Ocaml.VSum (("Do", [ v1; v2; v3; v4; v5 ]))
  | For ((v1, v2, v3, v4, v5, v6, v7, v8, v9)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      and v3 = vof_for_expr v3
      and v4 = vof_tok v4
      and v5 = vof_for_expr v5
      and v6 = vof_tok v6
      and v7 = vof_for_expr v7
      and v8 = vof_tok v8
      and v9 = vof_colon_stmt v9
      in Ocaml.VSum (("For", [ v1; v2; v3; v4; v5; v6; v7; v8; v9 ]))
  | Switch ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_expr v2
      and v3 = vof_switch_case_list v3
      in Ocaml.VSum (("Switch", [ v1; v2; v3 ]))
  | Foreach ((v1, v2, v3, v4, v5, v6, v7, v8)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      and v3 = vof_expr v3
      and v4 = vof_tok v4
      and v5 = Common.vof_either vof_foreach_variable vof_variable v5
      and v6 = vof_option vof_foreach_arrow v6
      and v7 = vof_tok v7
      and v8 = vof_colon_stmt v8
      in Ocaml.VSum (("Foreach", [ v1; v2; v3; v4; v5; v6; v7; v8 ]))
  | Break ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_option vof_expr v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Break", [ v1; v2; v3 ]))
  | Continue ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_option vof_expr v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Continue", [ v1; v2; v3 ]))
  | Return ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_option vof_expr v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Return", [ v1; v2; v3 ]))
  | Throw ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Throw", [ v1; v2; v3 ]))
  | Try ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_brace (vof_list vof_stmt_and_def) v2
      and v3 = vof_catch v3
      and v4 = vof_list vof_catch v4
      in Ocaml.VSum (("Try", [ v1; v2; v3; v4 ]))
  | Echo ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_expr v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Echo", [ v1; v2; v3 ]))
  | Globals ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_global_var v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Globals", [ v1; v2; v3 ]))
  | StaticVars ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_static_var v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("StaticVars", [ v1; v2; v3 ]))
  | InlineHtml v1 ->
      let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("InlineHtml", [ v1 ]))
  | Use ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_use_filename v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Use", [ v1; v2; v3 ]))
  | Unset ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_variable) v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Unset", [ v1; v2; v3 ]))
  | Declare ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_declare) v2
      and v3 = vof_colon_stmt v3
      in Ocaml.VSum (("Declare", [ v1; v2; v3 ]))
and vof_switch_case_list =
  function
  | CaseList ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_option vof_tok v2
      and v3 = vof_list vof_case v3
      and v4 = vof_tok v4
      in Ocaml.VSum (("CaseList", [ v1; v2; v3; v4 ]))
  | CaseColonList ((v1, v2, v3, v4, v5)) ->
      let v1 = vof_tok v1
      and v2 = vof_option vof_tok v2
      and v3 = vof_list vof_case v3
      and v4 = vof_tok v4
      and v5 = vof_tok v5
      in Ocaml.VSum (("CaseColonList", [ v1; v2; v3; v4; v5 ]))
and vof_case =
  function
  | Case ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_expr v2
      and v3 = vof_tok v3
      and v4 = vof_list vof_stmt_and_def v4
      in Ocaml.VSum (("Case", [ v1; v2; v3; v4 ]))
  | Default ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      and v3 = vof_list vof_stmt_and_def v3
      in Ocaml.VSum (("Default", [ v1; v2; v3 ]))
and vof_for_expr v = vof_comma_list vof_expr v
and vof_foreach_arrow (v1, v2) =
  let v1 = vof_tok v1
  and v2 = vof_foreach_variable v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_foreach_variable (v1, v2) =
  let v1 = vof_is_ref v1 and v2 = vof_variable v2 in Ocaml.VTuple [ v1; v2 ]
and vof_catch (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 =
    vof_paren
      (fun (v1, v2) ->
         let v1 = vof_fully_qualified_class_name v1
         and v2 = vof_dname v2
         in Ocaml.VTuple [ v1; v2 ])
      v2
  and v3 = vof_brace (vof_list vof_stmt_and_def) v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_use_filename =
  function
  | UseDirect v1 ->
      let v1 = vof_wrap vof_string v1 in Ocaml.VSum (("UseDirect", [ v1 ]))
  | UseParen v1 ->
      let v1 = vof_paren (vof_wrap vof_string) v1
      in Ocaml.VSum (("UseParen", [ v1 ]))
and vof_declare (v1, v2) =
  let v1 = vof_name v1
  and v2 = vof_static_scalar_affect v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_colon_stmt =
  function
  | SingleStmt v1 ->
      let v1 = vof_stmt v1 in Ocaml.VSum (("SingleStmt", [ v1 ]))
  | ColonStmt ((v1, v2, v3, v4)) ->
      let v1 = vof_tok v1
      and v2 = vof_list vof_stmt_and_def v2
      and v3 = vof_tok v3
      and v4 = vof_tok v4
      in Ocaml.VSum (("ColonStmt", [ v1; v2; v3; v4 ]))
and vof_new_elseif (v1, v2, v3, v4) =
  let v1 = vof_tok v1
  and v2 = vof_paren vof_expr v2
  and v3 = vof_tok v3
  and v4 = vof_list vof_stmt_and_def v4
  in Ocaml.VTuple [ v1; v2; v3; v4 ]
and vof_new_else (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = vof_tok v2
  and v3 = vof_list vof_stmt_and_def v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and
  vof_func_def {
                 f_tok = v_f_tok;
                 f_ref = v_f_ref;
                 f_name = v_f_name;
                 f_params = v_f_params;
                 f_body = v_f_body;
                 f_type = v_f_type
               } =
  let bnds = [] in
  let arg = Type_php.vof_phpfunction_type v_f_type in
  let bnd = ("f_type", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_brace (vof_list vof_stmt_and_def) v_f_body in
  let bnd = ("f_body", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_paren (vof_comma_list vof_parameter) v_f_params in
  let bnd = ("f_params", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_name v_f_name in
  let bnd = ("f_name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_is_ref v_f_ref in
  let bnd = ("f_ref", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_tok v_f_tok in
  let bnd = ("f_tok", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and
  vof_parameter {
                  p_type = v_p_type;
                  p_ref = v_p_ref;
                  p_name = v_p_name;
                  p_default = v_p_default
                } =
  let bnds = [] in
  let arg = vof_option vof_static_scalar_affect v_p_default in
  let bnd = ("p_default", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_dname v_p_name in
  let bnd = ("p_name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_is_ref v_p_ref in
  let bnd = ("p_ref", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_option vof_hint_type v_p_type in
  let bnd = ("p_type", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_hint_type =
  function
  | Hint v1 -> let v1 = vof_name v1 in Ocaml.VSum (("Hint", [ v1 ]))
  | HintArray v1 -> let v1 = vof_tok v1 in Ocaml.VSum (("HintArray", [ v1 ]))
and vof_is_ref v = vof_option vof_tok v

and vof_lexical_vars (v1, v2) =
  let v1 = vof_tok v1
  and v2 = vof_paren (vof_comma_list vof_lexical_var) v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_lexical_var =
  function
  | LexicalVar ((v1, v2)) ->
      let v1 = vof_is_ref v1
      and v2 = vof_dname v2
      in Ocaml.VSum (("LexicalVar", [ v1; v2 ]))

and  vof_lambda_def {
                   l_tok = v_l_tok;
                   l_ref = v_l_ref;
                   l_params = v_l_params;
                   l_use = v_l_use;
                   l_body = v_l_body
                 } =
  let bnds = [] in
  let arg = vof_brace (Ocaml.vof_list vof_stmt_and_def) v_l_body in
  let bnd = ("l_body", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_option vof_lexical_vars v_l_use in
  let bnd = ("l_use", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_paren (vof_comma_list vof_parameter) v_l_params in
  let bnd = ("l_params", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_is_ref v_l_ref in
  let bnd = ("l_ref", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_tok v_l_tok in
  let bnd = ("l_tok", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

and
  vof_class_def {
                  c_type = v_c_type;
                  c_name = v_c_name;
                  c_extends = v_c_extends;
                  c_implements = v_c_implements;
                  c_body = v_c_body
                } =
  let bnds = [] in
  let arg = vof_brace (vof_list vof_class_stmt) v_c_body in
  let bnd = ("c_body", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_option vof_interface v_c_implements in
  let bnd = ("c_implements", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_option vof_extend v_c_extends in
  let bnd = ("c_extends", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_name v_c_name in
  let bnd = ("c_name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_class_type v_c_type in
  let bnd = ("c_type", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_class_type =
  function
  | ClassRegular v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("ClassRegular", [ v1 ]))
  | ClassFinal ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("ClassFinal", [ v1; v2 ]))
  | ClassAbstract ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("ClassAbstract", [ v1; v2 ]))
and vof_extend (v1, v2) =
  let v1 = vof_tok v1
  and v2 = vof_fully_qualified_class_name v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_interface (v1, v2) =
  let v1 = vof_tok v1
  and v2 = vof_comma_list vof_fully_qualified_class_name v2
  in Ocaml.VTuple [ v1; v2 ]
and
  vof_interface_def {
                      i_tok = v_i_tok;
                      i_name = v_i_name;
                      i_extends = v_i_extends;
                      i_body = v_i_body
                    } =
  let bnds = [] in
  let arg = vof_brace (vof_list vof_class_stmt) v_i_body in
  let bnd = ("i_body", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_option vof_interface v_i_extends in
  let bnd = ("i_extends", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_name v_i_name in
  let bnd = ("i_name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_tok v_i_tok in
  let bnd = ("i_tok", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_class_stmt =
  function
  | ClassConstants ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_class_constant v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("ClassConstants", [ v1; v2; v3 ]))
  | ClassVariables ((v1, v2, v3)) ->
      let v1 = vof_class_var_modifier v1
      and v2 = vof_comma_list vof_class_variable v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("ClassVariables", [ v1; v2; v3 ]))
  | Method v1 ->
      let v1 = vof_method_def v1 in Ocaml.VSum (("Method", [ v1 ]))

  | XhpDecl v1 ->
      let v1 = vof_xhp_decl v1 in Ocaml.VSum (("XhpDecl", [ v1 ]))
and vof_class_constant (v1, v2) =
  let v1 = vof_name v1
  and v2 = vof_static_scalar_affect v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_class_variable (v1, v2) =
  let v1 = vof_dname v1
  and v2 = vof_option vof_static_scalar_affect v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_class_var_modifier =
  function
  | NoModifiers v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("NoModifiers", [ v1 ]))
  | VModifiers v1 ->
      let v1 = vof_list (vof_wrap vof_modifier) v1
      in Ocaml.VSum (("VModifiers", [ v1 ]))
and
  vof_method_def {
                   m_modifiers = v_m_modifiers;
                   m_tok = v_m_tok;
                   m_ref = v_m_ref;
                   m_name = v_m_name;
                   m_params = v_m_params;
                   m_body = v_m_body
                 } =
  let bnds = [] in
  let arg = vof_method_body v_m_body in
  let bnd = ("m_body", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_paren (vof_comma_list vof_parameter) v_m_params in
  let bnd = ("m_params", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_name v_m_name in
  let bnd = ("m_name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_is_ref v_m_ref in
  let bnd = ("m_ref", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_tok v_m_tok in
  let bnd = ("m_tok", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_list (vof_wrap vof_modifier) v_m_modifiers in
  let bnd = ("m_modifiers", arg) in
  let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_modifier =
  function
  | Public -> Ocaml.VSum (("Public", []))
  | Private -> Ocaml.VSum (("Private", []))
  | Protected -> Ocaml.VSum (("Protected", []))
  | Static -> Ocaml.VSum (("Static", []))
  | Abstract -> Ocaml.VSum (("Abstract", []))
  | Final -> Ocaml.VSum (("Final", []))
and vof_method_body =
  function
  | AbstractMethod v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("AbstractMethod", [ v1 ]))
  | MethodBody v1 ->
      let v1 = vof_brace (vof_list vof_stmt_and_def) v1
      in Ocaml.VSum (("MethodBody", [ v1 ]))
and vof_xhp_decl =
  function
  | XhpAttributesDecl ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_xhp_attribute_decl v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("XhpAttributesDecl", [ v1; v2; v3 ]))
  | XhpChildrenDecl ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_xhp_children_decl v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("XhpChildrenDecl", [ v1; v2; v3 ]))
  | XhpCategoriesDecl ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_comma_list vof_xhp_category_decl v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("XhpCategoriesDecl", [ v1; v2; v3 ]))
and vof_xhp_attribute_decl =
  function
  | XhpAttrInherit v1 ->
      let v1 = vof_wrap vof_xhp_tag v1
      in Ocaml.VSum (("XhpAttrInherit", [ v1 ]))
  | XhpAttrDecl ((v1, v2, v3, v4)) ->
      let v1 = vof_xhp_attribute_type v1
      and v2 = vof_xhp_attr_name v2
      and v3 = Ocaml.vof_option vof_xhp_value_affect v3
      and v4 = Ocaml.vof_option vof_tok v4
      in Ocaml.VSum (("XhpAttrDecl", [ v1; v2; v3; v4 ]))
and vof_xhp_attribute_type =
  function
  | XhpAttrType v1 ->
      let v1 = vof_name v1 in Ocaml.VSum (("XhpAttrType", [ v1 ]))
  | XhpAttrEnum ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_brace (vof_comma_list vof_constant) v2
      in Ocaml.VSum (("XhpAttrEnum", [ v1; v2 ]))
and vof_xhp_value_affect (v1, v2) =
  let v1 = vof_tok v1 and v2 = vof_constant v2 in Ocaml.VTuple [ v1; v2 ]
and vof_xhp_children_decl =
  function
  | XhpChild v1 ->
      let v1 = vof_wrap vof_xhp_tag v1 in Ocaml.VSum (("XhpChild", [ v1 ]))
  | XhpChildCategory v1 ->
      let v1 = vof_wrap vof_xhp_tag v1
      in Ocaml.VSum (("XhpChildCategory", [ v1 ]))
  | XhpChildAny v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("XhpChildAny", [ v1 ]))
  | XhpChildEmpty v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("XhpChildEmpty", [ v1 ]))
  | XhpChildPcdata v1 ->
      let v1 = vof_tok v1 in Ocaml.VSum (("XhpChildPcdata", [ v1 ]))
  | XhpChildSequence ((v1, v2, v3)) ->
      let v1 = vof_xhp_children_decl v1
      and v2 = vof_tok v2
      and v3 = vof_xhp_children_decl v3
      in Ocaml.VSum (("XhpChildSequence", [ v1; v2; v3 ]))
  | XhpChildAlternative ((v1, v2, v3)) ->
      let v1 = vof_xhp_children_decl v1
      and v2 = vof_tok v2
      and v3 = vof_xhp_children_decl v3
      in Ocaml.VSum (("XhpChildAlternative", [ v1; v2; v3 ]))
  | XhpChildMul ((v1, v2)) ->
      let v1 = vof_xhp_children_decl v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("XhpChildMul", [ v1; v2 ]))
  | XhpChildOption ((v1, v2)) ->
      let v1 = vof_xhp_children_decl v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("XhpChildOption", [ v1; v2 ]))
  | XhpChildPlus ((v1, v2)) ->
      let v1 = vof_xhp_children_decl v1
      and v2 = vof_tok v2
      in Ocaml.VSum (("XhpChildPlus", [ v1; v2 ]))
  | XhpChildParen v1 ->
      let v1 = vof_paren vof_xhp_children_decl v1
      in Ocaml.VSum (("XhpChildParen", [ v1 ]))
and vof_xhp_category_decl v = vof_wrap vof_xhp_tag v
and vof_global_var =
  function
  | GlobalVar v1 ->
      let v1 = vof_dname v1 in Ocaml.VSum (("GlobalVar", [ v1 ]))
  | GlobalDollar ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_r_variable v2
      in Ocaml.VSum (("GlobalDollar", [ v1; v2 ]))
  | GlobalDollarExpr ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_brace vof_expr v2
      in Ocaml.VSum (("GlobalDollarExpr", [ v1; v2 ]))
and vof_static_var (v1, v2) =
  let v1 = vof_dname v1
  and v2 = vof_option vof_static_scalar_affect v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_static_scalar =
  function
  | StaticConstant v1 ->
      let v1 = vof_constant v1 in Ocaml.VSum (("StaticConstant", [ v1 ]))
  | StaticClassConstant v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = vof_qualifier v1
             and v2 = vof_name v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("StaticClassConstant", [ v1 ]))
  | StaticPlus ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_static_scalar v2
      in Ocaml.VSum (("StaticPlus", [ v1; v2 ]))
  | StaticMinus ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_static_scalar v2
      in Ocaml.VSum (("StaticMinus", [ v1; v2 ]))
  | StaticArray ((v1, v2)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren (vof_comma_list vof_static_array_pair) v2
      in Ocaml.VSum (("StaticArray", [ v1; v2 ]))
  | XdebugStaticDots -> Ocaml.VSum (("XdebugStaticDots", []))
and vof_static_scalar_affect (v1, v2) =
  let v1 = vof_tok v1
  and v2 = vof_static_scalar v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_static_array_pair =
  function
  | StaticArraySingle v1 ->
      let v1 = vof_static_scalar v1
      in Ocaml.VSum (("StaticArraySingle", [ v1 ]))
  | StaticArrayArrow ((v1, v2, v3)) ->
      let v1 = vof_static_scalar v1
      and v2 = vof_tok v2
      and v3 = vof_static_scalar v3
      in Ocaml.VSum (("StaticArrayArrow", [ v1; v2; v3 ]))
and vof_stmt_and_def =
  function
  | Stmt v1 -> let v1 = vof_stmt v1 in Ocaml.VSum (("Stmt", [ v1 ]))
  | FuncDefNested v1 ->
      let v1 = vof_func_def v1 in Ocaml.VSum (("FuncDefNested", [ v1 ]))
  | ClassDefNested v1 ->
      let v1 = vof_class_def v1 in Ocaml.VSum (("ClassDefNested", [ v1 ]))
  | InterfaceDefNested v1 ->
      let v1 = vof_interface_def v1
      in Ocaml.VSum (("InterfaceDefNested", [ v1 ]))
and vof_toplevel =
  function
  | StmtList v1 ->
      let v1 = vof_list vof_stmt v1 in Ocaml.VSum (("StmtList", [ v1 ]))
  | FuncDef v1 ->
      let v1 = vof_func_def v1 in Ocaml.VSum (("FuncDef", [ v1 ]))
  | ClassDef v1 ->
      let v1 = vof_class_def v1 in Ocaml.VSum (("ClassDef", [ v1 ]))
  | InterfaceDef v1 ->
      let v1 = vof_interface_def v1 in Ocaml.VSum (("InterfaceDef", [ v1 ]))
  | Halt ((v1, v2, v3)) ->
      let v1 = vof_tok v1
      and v2 = vof_paren vof_unit v2
      and v3 = vof_tok v3
      in Ocaml.VSum (("Halt", [ v1; v2; v3 ]))
  | NotParsedCorrectly v1 ->
      let v1 = vof_list vof_info v1
      in Ocaml.VSum (("NotParsedCorrectly", [ v1 ]))
  | FinalDef v1 -> let v1 = vof_info v1 in Ocaml.VSum (("FinalDef", [ v1 ]))
and vof_program v = 
  profile_code "vof_program" (fun () ->
    vof_list vof_toplevel v
  )
  
(*****************************************************************************)
(* Ocaml.v -> type *)
(*****************************************************************************)
(* generated by ocamltarzan: ocamltarzan -ofv ast_php.ml *)



(* start of pfff specific stuff *)

let pinfo_ofv x = Parse_info.vtoken_ofv x
  
let rec info_ofv__ =
  let _loc = "Xxx.info"
  in
    function
    | (Ocaml.VDict field_sexps as sexp) ->
        let pinfo_field = ref None and comments_field = ref None
        and transfo_field = ref None and duplicates = ref []
        and extra = ref [] in
        let rec iter =
          (function
           | (field_name, field_sexp) :: tail ->
               ((match field_name with
                 | "pinfo" ->
                     (match !pinfo_field with
                      | None ->
                          let fvalue = pinfo_ofv field_sexp
                          in pinfo_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "comments" ->
                     (match !comments_field with
                      | None ->
                          let fvalue = Ocaml.unit_ofv field_sexp
                          in comments_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | "transfo" ->
                     (match !transfo_field with
                      | None ->
                          let fvalue = transformation_ofv field_sexp
                          in transfo_field := Some fvalue
                      | Some _ -> duplicates := field_name :: !duplicates)
                 | _ ->
                     if !Conv.record_check_extra_fields
                     then extra := field_name :: !extra
                     else ());
                iter tail)
           | [] -> ())
        in
          (iter field_sexps;
           if !duplicates <> []
           then Ocaml.record_duplicate_fields _loc !duplicates sexp
           else
             if !extra <> []
             then Ocaml.record_extra_fields _loc !extra sexp
             else
               (match ((!pinfo_field), (!comments_field), (!transfo_field))
                with
                | (Some pinfo_value, Some comments_value, Some transfo_value)
                    ->
                    {
                      pinfo = pinfo_value;
                      comments = comments_value;
                      transfo = transfo_value;
                    }
                | _ ->
                    Ocaml.record_undefined_elements _loc sexp
                      [ ((!pinfo_field = None), "pinfo");
                        ((!comments_field = None), "comments");
                        ((!transfo_field = None), "transfo") ]))
    | sexp -> Ocaml.record_list_instead_atom _loc sexp
and info_ofv sexp = info_ofv__ sexp
and transformation_ofv__ =
  let _loc = "Xxx.transformation"
  in
    function
    | Ocaml.VSum (("NoTransfo", [])) -> NoTransfo
    | Ocaml.VSum (("Remove", [])) -> Remove
    | (Ocaml.VSum (((("AddBefore" as tag)), sexp_args)) as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = add_ofv v1 in AddBefore v1
         | _ -> Ocaml.stag_incorrect_n_args _loc tag sexp)
    | (Ocaml.VSum (((("AddAfter" as tag)), sexp_args)) as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = add_ofv v1 in AddAfter v1
         | _ -> Ocaml.stag_incorrect_n_args _loc tag sexp)
    | (Ocaml.VSum (((("Replace" as tag)), sexp_args)) as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = add_ofv v1 in Replace v1
         | _ -> Ocaml.stag_incorrect_n_args _loc tag sexp)
    | sexp -> Ocaml.unexpected_stag _loc sexp
and transformation_ofv sexp = transformation_ofv__ sexp
and add_ofv__ =
  let _loc = "Xxx.add"
  in
    function
    | (Ocaml.VSum (((("AddStr" as tag)), sexp_args)) as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = Ocaml.string_ofv v1 in AddStr v1
         | _ -> Ocaml.stag_incorrect_n_args _loc tag sexp)
    | Ocaml.VSum (("AddNewlineAndIdent", [])) -> AddNewlineAndIdent
    | sexp -> Ocaml.unexpected_stag _loc sexp
and add_ofv sexp = add_ofv__ sexp

and wrap_ofv__ =
  let _loc = "Xxx.wrap"
  in
    fun _of_a ->
      function
      | Ocaml.VTuple ([ v1; v2 ]) ->
          let v1 = _of_a v1 and v2 = info_ofv v2 in (v1, v2)
      | sexp -> Ocaml.tuple_of_size_n_expected _loc 2 sexp
and wrap_ofv _of_a sexp =
  wrap_ofv__ _of_a sexp
  

and dname_ofv__ =
  let _loc = "Xxx.dname"
  in
    function
    | (Ocaml.VSum (((("DName" as tag)), sexp_args)) as sexp) ->
        (match sexp_args with
         | [ v1 ] -> let v1 = wrap_ofv Ocaml.string_ofv v1 in DName v1
         | _ -> Ocaml.stag_incorrect_n_args _loc tag sexp)
    | sexp -> Ocaml.unexpected_stag _loc sexp
and dname_ofv sexp = dname_ofv__ sexp
