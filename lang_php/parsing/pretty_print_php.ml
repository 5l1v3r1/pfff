(* Yoann Padioleau
 *
 * Copyright (C) 2011 Facebook
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 * 
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)
open Common

open Ocaml (* for v_int, v_bool, etc *)

open Ast_php

module Ast = Ast_php

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(* 
 * The goal of this module is (in the long term) to have a clean AST-based
 * PHP code pretty printer. This printer could indent the code defined in 
 * an AST correctly according to some style a la GNU indent.
 * This should help replace some of Bill's diff reviews by a script. 
 * 
 * Moreover it would make it easier to write some source-to-source
 * transformations. Right now the only way to do such transformation 
 * is to play with the 'transfo' field of some tokens and use 
 * Unparse_php which unparse a tokens-annotated AST. 
 * This is good for spatch but is tedious to use for more complex
 * transformations, e.g. some XHP optimisations. One just want to
 * use Map_php and transform some AST subelements in new elements
 * and just pretty print the resulting AST. One does not have to play
 * with the transfo field and work at the token level.
 * 
 * This module could also help spatch. Indeed right now 
 * the code generated by spatch is not always very well indented.
 * Fixing those indentation problems in the spatch engine would
 * be quite tricky. It's just simpler to have a naive spatch engine
 * and then an orthogonal reindentation fix phase done by a pretty
 * printer.
 * 
 * related modules:
 *  - export_ast_php.ml: to pretty print the OCaml AST so one can
 *    easily know to which OCaml constructor correspond a certain PHP 
 *    constructions
 *  - unparse_php.ml: does not really unparse the AST but instead
 *    unparse the annotated tokens.
 *  - pretty_print_pil.ml: at some point source-to-source optimizations
 *    should reuse use pretty_print_pil which is far simpler (but
 *    the PIL is currently not stable enough).
 * 
 * Right now it's just a very crude ugly AST unparser.
 *)

(*****************************************************************************)
(* Main code *)
(*****************************************************************************)

(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_visitor.cmo  pr_o.cmo /tmp/xxx.ml  *)

let v_ptype =
  function
  | BoolTy -> ()
  | IntTy -> ()
  | DoubleTy -> ()
  | StringTy -> ()
  | ArrayTy -> ()
  | ObjectTy -> ()

let rec v_info v = 
  pr (Ast.str_of_info v);
  ()

and v_tok v = 
  v_info v

and v_wrap _of_a (v1, v2) = let v1 = _of_a v1 and v2 = v_info v2 in ()
and v_paren _of_a (v1, v2, v3) =
  let v1 = v_tok v1 and v2 = _of_a v2 and v3 = v_tok v3 in ()
and v_brace _of_a (v1, v2, v3) =
  let v1 = v_tok v1 and v2 = _of_a v2 and v3 = v_tok v3 in ()
and v_bracket _of_a (v1, v2, v3) =
  let v1 = v_tok v1 and v2 = _of_a v2 and v3 = v_tok v3 in ()
and v_comma_list _of_a = v_list (Ocaml.v_either _of_a v_tok)

let rec v_name =
  function
  | Name v1 -> let v1 = v_wrap v_string v1 in ()
  | XhpName v1 -> let v1 = v_wrap v_xhp_tag v1 in ()
  
and v_xhp_tag v = v_list v_string v
and v_dname = function | DName v1 -> let v1 = v_wrap v_string v1 in ()
and v_qualifier =
  function
  | Qualifier ((v1, v2)) ->
      let v1 = v_fully_qualified_class_name v1 and v2 = v_tok v2 in ()
  | Self ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_tok v2 in ()
  | Parent ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_tok v2 in ()
and v_fully_qualified_class_name v = v_name v
  
let rec v_expr (v1, v2) = let v1 = v_exprbis v1 and v2 = v_exp_info v2 in ()
and v_exp_info { t = v_t } = 
  (* TODO let arg = Type_php.v_phptype v_t  *)
  ()
and v_exprbis =
  function
  | Lv v1 -> let v1 = v_lvalue v1 in ()
  | Sc v1 -> let v1 = v_scalar v1 in ()
  | Binary ((v1, v2, v3)) ->
      let v1 = v_expr v1
      and v2 = v_wrap v_binaryOp v2
      and v3 = v_expr v3
      in ()
  | Unary ((v1, v2)) -> let v1 = v_wrap v_unaryOp v1 and v2 = v_expr v2 in ()
  | Assign ((v1, v2, v3)) ->
      let v1 = v_lvalue v1 and v2 = v_tok v2 and v3 = v_expr v3 in ()
  | AssignOp ((v1, v2, v3)) ->
      let v1 = v_lvalue v1
      and v2 = v_wrap v_assignOp v2
      and v3 = v_expr v3
      in ()
  | Postfix ((v1, v2)) ->
      let v1 = v_rw_variable v1 and v2 = v_wrap v_fixOp v2 in ()
  | Infix ((v1, v2)) ->
      let v1 = v_wrap v_fixOp v1 and v2 = v_rw_variable v2 in ()
  | CondExpr ((v1, v2, v3, v4, v5)) ->
      let v1 = v_expr v1
      and v2 = v_tok v2
      and v3 = v_option v_expr v3
      and v4 = v_tok v4
      and v5 = v_expr v5
      in ()
  | AssignList ((v1, v2, v3, v4)) ->
      let v1 = v_tok v1
      and v2 = v_paren (v_comma_list v_list_assign) v2
      and v3 = v_tok v3
      and v4 = v_expr v4
      in ()
  | ConsArray ((v1, v2)) ->
      let v1 = v_tok v1 and v2 = v_paren (v_comma_list v_array_pair) v2 in ()
  | New ((v1, v2, v3)) ->
      let v1 = v_tok v1
      and v2 = v_class_name_reference v2
      and v3 = v_option (v_paren (v_comma_list v_argument)) v3
      in ()
  | Clone ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_expr v2 in ()
  | AssignRef ((v1, v2, v3, v4)) ->
      let v1 = v_lvalue v1
      and v2 = v_tok v2
      and v3 = v_tok v3
      and v4 = v_lvalue v4
      in ()
  | AssignNew ((v1, v2, v3, v4, v5, v6)) ->
      let v1 = v_lvalue v1
      and v2 = v_tok v2
      and v3 = v_tok v3
      and v4 = v_tok v4
      and v5 = v_class_name_reference v5
      and v6 = v_option (v_paren (v_comma_list v_argument)) v6
      in ()
  | Cast ((v1, v2)) -> let v1 = v_wrap v_castOp v1 and v2 = v_expr v2 in ()
  | CastUnset ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_expr v2 in ()
  | InstanceOf ((v1, v2, v3)) ->
      let v1 = v_expr v1
      and v2 = v_tok v2
      and v3 = v_class_name_reference v3
      in ()
  | Eval ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_paren v_expr v2 in ()
  | Lambda v1 -> let v1 = v_lambda_def v1 in ()
  | Exit ((v1, v2)) ->
      let v1 = v_tok v1
      and v2 = v_option (v_paren (v_option v_expr)) v2
      in ()
  | At ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_expr v2 in ()
  | Print ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_expr v2 in ()
  | BackQuote ((v1, v2, v3)) ->
      let v1 = v_tok v1 and v2 = v_list v_encaps v2 and v3 = v_tok v3 in ()
  | Include ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_expr v2 in ()
  | IncludeOnce ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_expr v2 in ()
  | Require ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_expr v2 in ()
  | RequireOnce ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_expr v2 in ()
  | Empty ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_paren v_lvalue v2 in ()
  | Isset ((v1, v2)) ->
      let v1 = v_tok v1 and v2 = v_paren (v_comma_list v_lvalue) v2 in ()
  | XhpHtml v1 -> let v1 = v_xhp_html v1 in ()
  | Yield ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_expr v2 in ()
  | YieldBreak ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_tok v2 in ()
  | SgrepExprDots v1 -> let v1 = v_info v1 in ()
  | ParenExpr v1 -> let v1 = v_paren v_expr v1 in ()
and v_scalar =
  function
  | C v1 -> let v1 = v_constant v1 in ()
  | ClassConstant v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) -> let v1 = v_qualifier v1 and v2 = v_name v2 in ())
      in ()
  | Guil ((v1, v2, v3)) ->
      let v1 = v_tok v1 and v2 = v_list v_encaps v2 and v3 = v_tok v3 in ()
  | HereDoc ((v1, v2, v3)) ->
      let v1 = v_tok v1 and v2 = v_list v_encaps v2 and v3 = v_tok v3 in ()
and v_constant =
  function
  | Int v1 -> let v1 = v_wrap v_string v1 in ()
  | Double v1 -> let v1 = v_wrap v_string v1 in ()
  | String v1 -> let v1 = v_wrap v_string v1 in ()
  | CName v1 -> let v1 = v_name v1 in ()
  | PreProcess v1 -> let v1 = v_wrap v_cpp_directive v1 in ()
  | XdebugClass ((v1, v2)) ->
      let v1 = v_name v1 and v2 = v_list v_class_stmt v2 in ()
  | XdebugResource -> ()
and v_cpp_directive =
  function
  | Line -> ()
  | File -> ()
  | ClassC -> ()
  | MethodC -> ()
  | FunctionC -> ()
and v_encaps =
  function
  | EncapsString v1 -> let v1 = v_wrap v_string v1 in ()
  | EncapsVar v1 -> let v1 = v_lvalue v1 in ()
  | EncapsCurly ((v1, v2, v3)) ->
      let v1 = v_tok v1 and v2 = v_lvalue v2 and v3 = v_tok v3 in ()
  | EncapsDollarCurly ((v1, v2, v3)) ->
      let v1 = v_tok v1 and v2 = v_lvalue v2 and v3 = v_tok v3 in ()
  | EncapsExpr ((v1, v2, v3)) ->
      let v1 = v_tok v1 and v2 = v_expr v2 and v3 = v_tok v3 in ()
and v_fixOp = function | Dec -> () | Inc -> ()
and v_binaryOp =
  function
  | Arith v1 -> let v1 = v_arithOp v1 in ()
  | Logical v1 -> let v1 = v_logicalOp v1 in ()
  | BinaryConcat -> ()
and v_arithOp =
  function
  | Plus -> ()
  | Minus -> ()
  | Mul -> ()
  | Div -> ()
  | Mod -> ()
  | DecLeft -> ()
  | DecRight -> ()
  | And -> ()
  | Or -> ()
  | Xor -> ()
and v_logicalOp =
  function
  | Inf -> ()
  | Sup -> ()
  | InfEq -> ()
  | SupEq -> ()
  | Eq -> ()
  | NotEq -> ()
  | Identical -> ()
  | NotIdentical -> ()
  | AndLog -> ()
  | OrLog -> ()
  | XorLog -> ()
  | AndBool -> ()
  | OrBool -> ()
and v_assignOp =
  function
  | AssignOpArith v1 -> let v1 = v_arithOp v1 in ()
  | AssignConcat -> ()
and v_unaryOp =
  function | UnPlus -> () | UnMinus -> () | UnBang -> () | UnTilde -> ()
and v_castOp v = v_ptype v
and v_list_assign =
  function
  | ListVar v1 -> let v1 = v_lvalue v1 in ()
  | ListList ((v1, v2)) ->
      let v1 = v_tok v1
      and v2 = v_paren (v_comma_list v_list_assign) v2
      in ()
  | ListEmpty -> ()
and v_array_pair =
  function
  | ArrayExpr v1 -> let v1 = v_expr v1 in ()
  | ArrayRef ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_lvalue v2 in ()
  | ArrayArrowExpr ((v1, v2, v3)) ->
      let v1 = v_expr v1 and v2 = v_tok v2 and v3 = v_expr v3 in ()
  | ArrayArrowRef ((v1, v2, v3, v4)) ->
      let v1 = v_expr v1
      and v2 = v_tok v2
      and v3 = v_tok v3
      and v4 = v_lvalue v4
      in ()
and v_class_name_reference =
  function
  | ClassNameRefStatic v1 -> let v1 = v_class_name_or_selfparent v1 in ()
  | ClassNameRefDynamic v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = v_lvalue v1 and v2 = v_list v_obj_prop_access v2 in ())
      in ()
and v_class_name_or_selfparent x = v_fully_qualified_class_name x

and v_obj_prop_access (v1, v2) =
  let v1 = v_tok v1 and v2 = v_obj_property v2 in ()
and v_xhp_html =
  function
  | Xhp ((v1, v2, v3, v4, v5)) ->
      let v1 = v_wrap v_xhp_tag v1
      and v2 = v_list v_xhp_attribute v2
      and v3 = v_tok v3
      and v4 = v_list v_xhp_body v4
      and v5 = v_wrap (v_option v_xhp_tag) v5
      in ()
  | XhpSingleton ((v1, v2, v3)) ->
      let v1 = v_wrap v_xhp_tag v1
      and v2 = v_list v_xhp_attribute v2
      and v3 = v_tok v3
      in ()
and v_xhp_attribute (v1, v2, v3) =
  let v1 = v_xhp_attr_name v1
  and v2 = v_tok v2
  and v3 = v_xhp_attr_value v3
  in ()
and v_xhp_attr_name v = v_wrap v_string v
and v_xhp_attr_value =
  function
  | XhpAttrString ((v1, v2, v3)) ->
      let v1 = v_tok v1 and v2 = v_list v_encaps v2 and v3 = v_tok v3 in ()
  | XhpAttrExpr v1 -> let v1 = v_brace v_expr v1 in ()
  | SgrepXhpAttrValueMvar v1 -> let v1 = v_wrap v_string v1 in ()
and v_xhp_body =
  function
  | XhpText v1 -> let v1 = v_wrap v_string v1 in ()
  | XhpExpr v1 -> let v1 = v_brace v_expr v1 in ()
  | XhpNested v1 -> let v1 = v_xhp_html v1 in ()
and v_lvalue (v1, v2) =
  let v1 = v_lvaluebis v1 and v2 = v_lvalue_info v2 in ()
and v_lvalue_info { tlval = v_tlval } =
  (*let arg = Type_php.v_phptype v_tlval in *)
  ()
and v_lvaluebis =
  function
  | Var ((v1, v2)) ->
      let v1 = v_dname v1  in
      (*and v2 = v_ref Scope_php.v_phpscope v2 in *) ()
  | This v1 -> let v1 = v_tok v1 in ()
  | VArrayAccess ((v1, v2)) ->
      let v1 = v_lvalue v1 and v2 = v_bracket (v_option v_expr) v2 in ()
  | VArrayAccessXhp ((v1, v2)) ->
      let v1 = v_expr v1 and v2 = v_bracket (v_option v_expr) v2 in ()
  | VBrace ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_brace v_expr v2 in ()
  | VBraceAccess ((v1, v2)) ->
      let v1 = v_lvalue v1 and v2 = v_brace v_expr v2 in ()
  | Indirect ((v1, v2)) -> let v1 = v_lvalue v1 and v2 = v_indirect v2 in ()
  | VQualifier ((v1, v2)) ->
      let v1 = v_qualifier v1 and v2 = v_lvalue v2 in ()
  | ClassVar ((v1, v2)) -> let v1 = v_qualifier v1 and v2 = v_dname v2 in ()
  | FunCallSimple ((v1, v2)) ->
      let v1 = v_name v1 and v2 = v_paren (v_comma_list v_argument) v2 in ()
  | FunCallVar ((v1, v2, v3)) ->
      let v1 = v_option v_qualifier v1
      and v2 = v_lvalue v2
      and v3 = v_paren (v_comma_list v_argument) v3
      in ()
  | StaticMethodCallSimple ((v1, v2, v3)) ->
      let v1 = v_qualifier v1
      and v2 = v_name v2
      and v3 = v_paren (v_comma_list v_argument) v3
      in ()
  | MethodCallSimple ((v1, v2, v3, v4)) ->
      let v1 = v_lvalue v1
      and v2 = v_tok v2
      and v3 = v_name v3
      and v4 = v_paren (v_comma_list v_argument) v4
      in ()
  | StaticMethodCallVar ((v1, v2, v3, v4)) ->
      let v1 = v_lvalue v1
      and v2 = v_tok v2
      and v3 = v_name v3
      and v4 = v_paren (v_comma_list v_argument) v4
      in ()
  | StaticObjCallVar ((v1, v2, v3, v4)) ->
      let v1 = v_lvalue v1
      and v2 = v_tok v2
      and v3 = v_lvalue v3
      and v4 = v_paren (v_comma_list v_argument) v4
      in ()
  | ObjAccessSimple ((v1, v2, v3)) ->
      let v1 = v_lvalue v1 and v2 = v_tok v2 and v3 = v_name v3 in ()
  | ObjAccess ((v1, v2)) ->
      let v1 = v_lvalue v1 and v2 = v_obj_access v2 in ()
and v_indirect = function | Dollar v1 -> let v1 = v_tok v1 in ()
and v_argument =
  function
  | Arg v1 -> let v1 = v_expr v1 in ()
  | ArgRef ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_w_variable v2 in ()
and v_obj_access (v1, v2, v3) =
  let v1 = v_tok v1
  and v2 = v_obj_property v2
  and v3 = v_option (v_paren (v_comma_list v_argument)) v3
  in ()
and v_obj_property =
  function
  | ObjProp v1 -> let v1 = v_obj_dim v1 in ()
  | ObjPropVar v1 -> let v1 = v_lvalue v1 in ()
and v_obj_dim =
  function
  | OName v1 -> let v1 = v_name v1 in ()
  | OBrace v1 -> let v1 = v_brace v_expr v1 in ()
  | OArrayAccess ((v1, v2)) ->
      let v1 = v_obj_dim v1 and v2 = v_bracket (v_option v_expr) v2 in ()
  | OBraceAccess ((v1, v2)) ->
      let v1 = v_obj_dim v1 and v2 = v_brace v_expr v2 in ()
and v_rw_variable v = v_lvalue v
and v_r_variable v = v_lvalue v
and v_w_variable v = v_lvalue v
and v_stmt =
  function
  | ExprStmt ((v1, v2)) -> let v1 = v_expr v1 and v2 = v_tok v2 in ()
  | EmptyStmt v1 -> let v1 = v_tok v1 in ()
  | Block v1 -> let v1 = v_brace (v_list v_stmt_and_def) v1 in ()
  | If ((v1, v2, v3, v4, v5)) ->
      let v1 = v_tok v1
      and v2 = v_paren v_expr v2
      and v3 = v_stmt v3
      and v4 = v_list v_if_elseif v4
      and v5 = v_option v_if_else v5
      in ()
  | IfColon ((v1, v2, v3, v4, v5, v6, v7, v8)) ->
      let v1 = v_tok v1
      and v2 = v_paren v_expr v2
      and v3 = v_tok v3
      and v4 = v_list v_stmt_and_def v4
      and v5 = v_list v_new_elseif v5
      and v6 = v_option v_new_else v6
      and v7 = v_tok v7
      and v8 = v_tok v8
      in ()
  | While ((v1, v2, v3)) ->
      let v1 = v_tok v1
      and v2 = v_paren v_expr v2
      and v3 = v_colon_stmt v3
      in ()
  | Do ((v1, v2, v3, v4, v5)) ->
      let v1 = v_tok v1
      and v2 = v_stmt v2
      and v3 = v_tok v3
      and v4 = v_paren v_expr v4
      and v5 = v_tok v5
      in ()
  | For ((v1, v2, v3, v4, v5, v6, v7, v8, v9)) ->
      let v1 = v_tok v1
      and v2 = v_tok v2
      and v3 = v_for_expr v3
      and v4 = v_tok v4
      and v5 = v_for_expr v5
      and v6 = v_tok v6
      and v7 = v_for_expr v7
      and v8 = v_tok v8
      and v9 = v_colon_stmt v9
      in ()
  | Switch ((v1, v2, v3)) ->
      let v1 = v_tok v1
      and v2 = v_paren v_expr v2
      and v3 = v_switch_case_list v3
      in ()
  | Foreach ((v1, v2, v3, v4, v5, v6, v7, v8)) ->
      let v1 = v_tok v1
      and v2 = v_tok v2
      and v3 = v_expr v3
      and v4 = v_tok v4
      and v5 = v_foreach_var_either v5
      and v6 = v_option v_foreach_arrow v6
      and v7 = v_tok v7
      and v8 = v_colon_stmt v8
      in ()
  | Break ((v1, v2, v3)) ->
      let v1 = v_tok v1 and v2 = v_option v_expr v2 and v3 = v_tok v3 in ()
  | Continue ((v1, v2, v3)) ->
      let v1 = v_tok v1 and v2 = v_option v_expr v2 and v3 = v_tok v3 in ()
  | Return ((v1, v2, v3)) ->
      let v1 = v_tok v1 and v2 = v_option v_expr v2 and v3 = v_tok v3 in ()
  | Throw ((v1, v2, v3)) ->
      let v1 = v_tok v1 and v2 = v_expr v2 and v3 = v_tok v3 in ()
  | Try ((v1, v2, v3, v4)) ->
      let v1 = v_tok v1
      and v2 = v_brace (v_list v_stmt_and_def) v2
      and v3 = v_catch v3
      and v4 = v_list v_catch v4
      in ()
  | Echo ((v1, v2, v3)) ->
      let v1 = v_tok v1
      and v2 = v_comma_list v_expr v2
      and v3 = v_tok v3
      in ()
  | Globals ((v1, v2, v3)) ->
      let v1 = v_tok v1
      and v2 = v_comma_list v_global_var v2
      and v3 = v_tok v3
      in ()
  | StaticVars ((v1, v2, v3)) ->
      let v1 = v_tok v1
      and v2 = v_comma_list v_static_var v2
      and v3 = v_tok v3
      in ()
  | InlineHtml v1 -> let v1 = v_wrap v_string v1 in ()
  | Use ((v1, v2, v3)) ->
      let v1 = v_tok v1 and v2 = v_use_filename v2 and v3 = v_tok v3 in ()
  | Unset ((v1, v2, v3)) ->
      let v1 = v_tok v1
      and v2 = v_paren (v_comma_list v_lvalue) v2
      and v3 = v_tok v3
      in ()
  | Declare ((v1, v2, v3)) ->
      let v1 = v_tok v1
      and v2 = v_paren (v_comma_list v_declare) v2
      and v3 = v_colon_stmt v3
      in ()
  | TypedDeclaration ((v1, v2, v3, v4)) ->
      let v1 = v_hint_type v1
      and v2 = v_lvalue v2
      and v3 =
        v_option (fun (v1, v2) -> let v1 = v_tok v1 and v2 = v_expr v2 in ())
          v3
      and v4 = v_tok v4
      in ()
and v_switch_case_list =
  function
  | CaseList ((v1, v2, v3, v4)) ->
      let v1 = v_tok v1
      and v2 = v_option v_tok v2
      and v3 = v_list v_case v3
      and v4 = v_tok v4
      in ()
  | CaseColonList ((v1, v2, v3, v4, v5)) ->
      let v1 = v_tok v1
      and v2 = v_option v_tok v2
      and v3 = v_list v_case v3
      and v4 = v_tok v4
      and v5 = v_tok v5
      in ()
and v_case =
  function
  | Case ((v1, v2, v3, v4)) ->
      let v1 = v_tok v1
      and v2 = v_expr v2
      and v3 = v_tok v3
      and v4 = v_list v_stmt_and_def v4
      in ()
  | Default ((v1, v2, v3)) ->
      let v1 = v_tok v1
      and v2 = v_tok v2
      and v3 = v_list v_stmt_and_def v3
      in ()
and v_if_elseif (v1, v2, v3) =
  let v1 = v_tok v1 and v2 = v_paren v_expr v2 and v3 = v_stmt v3 in ()
and v_if_else (v1, v2) = let v1 = v_tok v1 and v2 = v_stmt v2 in ()
and v_for_expr v = v_comma_list v_expr v
and v_foreach_arrow (v1, v2) =
  let v1 = v_tok v1 and v2 = v_foreach_variable v2 in ()
and v_foreach_variable (v1, v2) =
  let v1 = v_is_ref v1 and v2 = v_lvalue v2 in ()
and v_foreach_var_either v = Ocaml.v_either v_foreach_variable v_lvalue v
and v_catch (v1, v2, v3) =
  let v1 = v_tok v1
  and v2 =
    v_paren
      (fun (v1, v2) ->
         let v1 = v_fully_qualified_class_name v1 and v2 = v_dname v2 in ())
      v2
  and v3 = v_brace (v_list v_stmt_and_def) v3
  in ()
and v_use_filename =
  function
  | UseDirect v1 -> let v1 = v_wrap v_string v1 in ()
  | UseParen v1 -> let v1 = v_paren (v_wrap v_string) v1 in ()
and v_declare (v1, v2) =
  let v1 = v_name v1 and v2 = v_static_scalar_affect v2 in ()
and v_colon_stmt =
  function
  | SingleStmt v1 -> let v1 = v_stmt v1 in ()
  | ColonStmt ((v1, v2, v3, v4)) ->
      let v1 = v_tok v1
      and v2 = v_list v_stmt_and_def v2
      and v3 = v_tok v3
      and v4 = v_tok v4
      in ()
and v_new_elseif (v1, v2, v3, v4) =
  let v1 = v_tok v1
  and v2 = v_paren v_expr v2
  and v3 = v_tok v3
  and v4 = v_list v_stmt_and_def v4
  in ()
and v_new_else (v1, v2, v3) =
  let v1 = v_tok v1 and v2 = v_tok v2 and v3 = v_list v_stmt_and_def v3 in ()
and
  v_func_def {
               f_tok = v_f_tok;
               f_ref = v_f_ref;
               f_name = v_f_name;
               f_params = v_f_params;
               f_return_type = v_f_return_type;
               f_body = v_f_body;
               f_type = v_f_type
             } =
  let arg = v_tok v_f_tok in
  let arg = v_is_ref v_f_ref in
  let arg = v_name v_f_name in
  let arg = v_paren (v_comma_list v_parameter) v_f_params in
  let arg = v_option v_hint_type v_f_return_type in
  let arg = v_brace (v_list v_stmt_and_def) v_f_body in
  (* let arg = Type_php.v_phptype v_f_type in *)
  ()
and
  v_parameter {
                p_type = v_p_type;
                p_ref = v_p_ref;
                p_name = v_p_name;
                p_default = v_p_default
              } =
  let arg = v_option v_hint_type v_p_type in
  let arg = v_is_ref v_p_ref in
  let arg = v_dname v_p_name in
  let arg = v_option v_static_scalar_affect v_p_default in ()
and v_hint_type =
  function
  | Hint v1 -> let v1 = v_class_name_or_selfparent v1 in ()
  | HintArray v1 -> let v1 = v_tok v1 in ()
and v_is_ref v = v_option v_tok v
and
  v_lambda_def {
                 l_tok = v_l_tok;
                 l_ref = v_l_ref;
                 l_params = v_l_params;
                 l_use = v_l_use;
                 l_body = v_l_body
               } =
  let arg = v_tok v_l_tok in
  let arg = v_is_ref v_l_ref in
  let arg = v_paren (v_comma_list v_parameter) v_l_params in
  let arg = v_option v_lexical_vars v_l_use in
  let arg = v_brace (v_list v_stmt_and_def) v_l_body in ()
and v_lexical_vars (v1, v2) =
  let v1 = v_tok v1 and v2 = v_paren (v_comma_list v_lexical_var) v2 in ()
and v_lexical_var =
  function
  | LexicalVar ((v1, v2)) -> let v1 = v_is_ref v1 and v2 = v_dname v2 in ()
and
  v_class_def {
                c_type = v_c_type;
                c_name = v_c_name;
                c_extends = v_c_extends;
                c_implements = v_c_implements;
                c_body = v_c_body
              } =
  let arg = v_class_type v_c_type in
  let arg = v_name v_c_name in
  let arg = v_option v_extend v_c_extends in
  let arg = v_option v_interface v_c_implements in
  let arg = v_brace (v_list v_class_stmt) v_c_body in ()
and v_class_type =
  function
  | ClassRegular v1 -> let v1 = v_tok v1 in ()
  | ClassFinal ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_tok v2 in ()
  | ClassAbstract ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_tok v2 in ()
and v_extend (v1, v2) =
  let v1 = v_tok v1 and v2 = v_fully_qualified_class_name v2 in ()
and v_interface (v1, v2) =
  let v1 = v_tok v1
  and v2 = v_comma_list v_fully_qualified_class_name v2
  in ()
and
  v_interface_def {
                    i_tok = v_i_tok;
                    i_name = v_i_name;
                    i_extends = v_i_extends;
                    i_body = v_i_body
                  } =
  let arg = v_tok v_i_tok in
  let arg = v_name v_i_name in
  let arg = v_option v_interface v_i_extends in
  let arg = v_brace (v_list v_class_stmt) v_i_body in ()
and v_class_stmt =
  function
  | ClassConstants ((v1, v2, v3)) ->
      let v1 = v_tok v1
      and v2 = v_comma_list v_class_constant v2
      and v3 = v_tok v3
      in ()
  | ClassVariables ((v1, v2, v3, v4)) ->
      let v1 = v_class_var_modifier v1
      and v2 = v_option v_hint_type v2
      and v3 = v_comma_list v_class_variable v3
      and v4 = v_tok v4
      in ()
  | Method v1 -> let v1 = v_method_def v1 in ()
  | XhpDecl v1 -> let v1 = v_xhp_decl v1 in ()
and v_class_constant (v1, v2) =
  let v1 = v_name v1 and v2 = v_static_scalar_affect v2 in ()
and v_class_variable (v1, v2) =
  let v1 = v_dname v1 and v2 = v_option v_static_scalar_affect v2 in ()
and v_class_var_modifier =
  function
  | NoModifiers v1 -> let v1 = v_tok v1 in ()
  | VModifiers v1 -> let v1 = v_list (v_wrap v_modifier) v1 in ()
and
  v_method_def {
                 m_modifiers = v_m_modifiers;
                 m_tok = v_m_tok;
                 m_ref = v_m_ref;
                 m_name = v_m_name;
                 m_params = v_m_params;
                 m_return_type = v_m_return_type;
                 m_body = v_m_body
               } =
  let arg = v_list (v_wrap v_modifier) v_m_modifiers in
  let arg = v_tok v_m_tok in
  let arg = v_is_ref v_m_ref in
  let arg = v_name v_m_name in
  let arg = v_paren (v_comma_list v_parameter) v_m_params in
  let arg = v_option v_hint_type v_m_return_type in
  let arg = v_method_body v_m_body in ()
and v_modifier =
  function
  | Public -> ()
  | Private -> ()
  | Protected -> ()
  | Static -> ()
  | Abstract -> ()
  | Final -> ()
and v_method_body =
  function
  | AbstractMethod v1 -> let v1 = v_tok v1 in ()
  | MethodBody v1 -> let v1 = v_brace (v_list v_stmt_and_def) v1 in ()
and v_xhp_decl =
  function
  | XhpAttributesDecl ((v1, v2, v3)) ->
      let v1 = v_tok v1
      and v2 = v_comma_list v_xhp_attribute_decl v2
      and v3 = v_tok v3
      in ()
  | XhpChildrenDecl ((v1, v2, v3)) ->
      let v1 = v_tok v1
      and v2 = v_xhp_children_decl v2
      and v3 = v_tok v3
      in ()
  | XhpCategoriesDecl ((v1, v2, v3)) ->
      let v1 = v_tok v1
      and v2 = v_comma_list v_xhp_category_decl v2
      and v3 = v_tok v3
      in ()
and v_xhp_attribute_decl =
  function
  | XhpAttrInherit v1 -> let v1 = v_wrap v_xhp_tag v1 in ()
  | XhpAttrDecl ((v1, v2, v3, v4)) ->
      let v1 = v_xhp_attribute_type v1
      and v2 = v_xhp_attr_name v2
      and v3 = v_option v_xhp_value_affect v3
      and v4 = v_option v_tok v4
      in ()
and v_xhp_attribute_type =
  function
  | XhpAttrType v1 -> let v1 = v_name v1 in ()
  | XhpAttrEnum ((v1, v2)) ->
      let v1 = v_tok v1 and v2 = v_brace (v_comma_list v_constant) v2 in ()
and v_xhp_value_affect (v1, v2) =
  let v1 = v_tok v1 and v2 = v_constant v2 in ()
and v_xhp_children_decl =
  function
  | XhpChild v1 -> let v1 = v_wrap v_xhp_tag v1 in ()
  | XhpChildCategory v1 -> let v1 = v_wrap v_xhp_tag v1 in ()
  | XhpChildAny v1 -> let v1 = v_tok v1 in ()
  | XhpChildEmpty v1 -> let v1 = v_tok v1 in ()
  | XhpChildPcdata v1 -> let v1 = v_tok v1 in ()
  | XhpChildSequence ((v1, v2, v3)) ->
      let v1 = v_xhp_children_decl v1
      and v2 = v_tok v2
      and v3 = v_xhp_children_decl v3
      in ()
  | XhpChildAlternative ((v1, v2, v3)) ->
      let v1 = v_xhp_children_decl v1
      and v2 = v_tok v2
      and v3 = v_xhp_children_decl v3
      in ()
  | XhpChildMul ((v1, v2)) ->
      let v1 = v_xhp_children_decl v1 and v2 = v_tok v2 in ()
  | XhpChildOption ((v1, v2)) ->
      let v1 = v_xhp_children_decl v1 and v2 = v_tok v2 in ()
  | XhpChildPlus ((v1, v2)) ->
      let v1 = v_xhp_children_decl v1 and v2 = v_tok v2 in ()
  | XhpChildParen v1 -> let v1 = v_paren v_xhp_children_decl v1 in ()
and v_xhp_category_decl v = v_wrap v_xhp_tag v
and v_global_var =
  function
  | GlobalVar v1 -> let v1 = v_dname v1 in ()
  | GlobalDollar ((v1, v2)) ->
      let v1 = v_tok v1 and v2 = v_r_variable v2 in ()
  | GlobalDollarExpr ((v1, v2)) ->
      let v1 = v_tok v1 and v2 = v_brace v_expr v2 in ()
and v_static_var (v1, v2) =
  let v1 = v_dname v1 and v2 = v_option v_static_scalar_affect v2 in ()
and v_static_scalar =
  function
  | StaticConstant v1 -> let v1 = v_constant v1 in ()
  | StaticClassConstant v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) -> let v1 = v_qualifier v1 and v2 = v_name v2 in ())
      in ()
  | StaticPlus ((v1, v2)) ->
      let v1 = v_tok v1 and v2 = v_static_scalar v2 in ()
  | StaticMinus ((v1, v2)) ->
      let v1 = v_tok v1 and v2 = v_static_scalar v2 in ()
  | StaticArray ((v1, v2)) ->
      let v1 = v_tok v1
      and v2 = v_paren (v_comma_list v_static_array_pair) v2
      in ()
  | XdebugStaticDots -> ()
and v_static_scalar_affect (v1, v2) =
  let v1 = v_tok v1 and v2 = v_static_scalar v2 in ()
and v_static_array_pair =
  function
  | StaticArraySingle v1 -> let v1 = v_static_scalar v1 in ()
  | StaticArrayArrow ((v1, v2, v3)) ->
      let v1 = v_static_scalar v1
      and v2 = v_tok v2
      and v3 = v_static_scalar v3
      in ()
and v_stmt_and_def =
  function
  | Stmt v1 -> let v1 = v_stmt v1 in ()
  | FuncDefNested v1 -> let v1 = v_func_def v1 in ()
  | ClassDefNested v1 -> let v1 = v_class_def v1 in ()
  | InterfaceDefNested v1 -> let v1 = v_interface_def v1 in ()
and v_toplevel =
  function
  | StmtList v1 -> let v1 = v_list v_stmt v1 in ()
  | FuncDef v1 -> let v1 = v_func_def v1 in ()
  | ClassDef v1 -> let v1 = v_class_def v1 in ()
  | InterfaceDef v1 -> let v1 = v_interface_def v1 in ()
  | Halt ((v1, v2, v3)) ->
      let v1 = v_tok v1 and v2 = v_paren v_unit v2 and v3 = v_tok v3 in ()
  | NotParsedCorrectly v1 -> let v1 = v_list v_info v1 in ()
  | FinalDef v1 -> let v1 = v_info v1 in ()

and v_program v = v_list v_toplevel v

and pretty_print_program x = 
  pr "<?php";
  v_program x
