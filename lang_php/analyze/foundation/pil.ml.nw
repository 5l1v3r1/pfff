
\section{Overview}

<<pil.ml>>=
<<Facebook copyright>>

open Common 

module Ast = Ast_php


(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*
 * The Ast_php module is nice when you want to do some simple analysis
 * or refactoring as it directly matches the source code; error reporting
 * is precise and unparsing a modified AST leads to a file that is
 * close to the original coding style. Unfortunately this AST, which
 * is in fact more a CST for Concrete Syntax Tree is not very convenient
 * for heavier static analysis such as data flow tracking. 
 * 
 * Indeed, PHP is a large language and as a consequence Ast_php contains 
 * lots of constructors with many many cases to handle for the analysis 
 * writer. For instance incrementing a variable can be written as
 *  $i = $i + 1; or $i++; or ++$i;  which in our AST is represented by
 * 3 different constructs.  Moreover some important constructs
 * such as function calls or assignements can be very
 * deeply nested inside an expression. One can obviously write in PHP
 * x = foo() + y = bar();  and this would be naively represented
 * as a single node in a CFG; matching over function calls
 * or assignements would require then to write visitors over those nodes.
 * Even include/require constructs are represented at the expression level
 * whereas they should be really more at the toplevel or at least
 * statement level.
 * 
 * Enter PIL for PHP Intermediate Language, a better representation
 * for a PHP program. We just follow the tradition started by
 * CIL[1] and RIL[2] and propose here an AST bis which makes it
 * easier to write some static analysis.
 * 
 * Maybe I should focus on Ast_php because if we want to transform code
 * we have to work on that. But working on Pil can also help
 * clarify my comprehension of PHP :) It could also maybe make it
 * easier to write the type inferer later.
 * 
 * 
 * I try, just like in Ast_php, to keep position information for the
 * elements in PIL, but I do it less. For instance comma_list or paren
 * stuff are removed here.
 * 
 * TODO: does the linearization respect the semantic of PHP ? Is there
 * cases where spliting a complex expression into multiple parts
 * with intermediate variables leads to a different semantic ?
 * For instance apparently $i++ is not equivalent to $i = $i + 1 when
 * $i is a string. Wonderful PHP. But at the same time our goal here is
 * not to write a compiler. Our goal is to find bugs so we may relax some
 * requirements.
 * 
 * References:
 *  [1] CIL, C Intermediate Language, Necula et al, CC'00
 *  [2] The Ruby Intermediate Language, Furr et al, DSL'09
 *)
(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* aliases. For now we reuse the types from Ast_php but this may change. *)
type qualifier = Ast_php.qualifier
type indirect = Ast_php.indirect

type binaryOp = Ast_php.binaryOp
type unaryOp = Ast_php.unaryOp
type assignOp = Ast_php.assignOp
type castOp = Ast_php.castOp

type constant = Ast_php.constant
type class_name_reference = Ast_php.class_name_reference

type name = Ast_php.name
type dname = Ast_php.dname



(* We may want to use Pil instead of Ast_php for the type inference
 * analysis at some point.
 *)
type type_info = {
  mutable t: Type_php.phptype;
}
 (* with tarzan *)

(* 'var' can be an existing variable (e.g. $xxx) of a fake and fresh
 * generated variable resulting from the linearization of an expression.
 *)
type var = 
  | Var of dname
  (* todo? move in lvalue ? after all $this[2] is not possible *)
  | This of Ast_php.tok
 (* with tarzan *)

(* 'lvalue', what can appear at the left side of an assignement. 
 *
 * Note that as opposed to Ast_php.lvalue a linearization has been done so
 * $o->fld1->fld2 will be transformed in $obis = $o->fld1; $obis->fld2;
 * So lvalue is not a a recursive type (there is no lvalue inside
 * a lvalue). 
 * Also note that function or method calls are not there (but in 'instr').
 *)
type lvalue = lvaluebis * type_info
 and lvaluebis = 
   | VVar of var
   | VQualifier of qualifier * var

   | ArrayAccess of var * expr option
   | ObjAccess of var * name
   | DynamicObjAccess of var * var
   | IndirectAccess of var * indirect
   (* todo: VBraceXxx ?? ObjAccess ? *)

(* 'expr' is side effect free (as opposed to Ast_php.expr) ! 
 *  
 * Moreover this type does not contain:
 * - assignements
 * - function calls (was in the lvalue)
 * - include/require (wtf they were doing in expr anyway ...)
 * 
 * Also the constant type has been promoted one level up.
 *)
and expr = exprbis * type_info
 and exprbis =
  | Lv of lvalue
  | C of constant
  | ClassConstant of (qualifier * name)

  (* Could be grouped in a Builtin of string_op * expr list.
   * todo? do something special for short-circuit operators as in CIL ?
   *)
  | Binary  of expr * binaryOp * expr
  | Unary   of unaryOp * expr
  | CondExpr of expr * expr * expr

  (* todo: apparently can put some refs & inside array() expressions *)
  | ConsArray of expr list
  | ConsHash  of (expr * expr) list

  | Cast of castOp * expr
  | InstanceOf of expr * class_name_reference
  (* todo: remaining Sc (Guil, etc), CastUnset, *)

 (* with tarzan *)

(* an instruction is a statement that has no local (intraprocedural) 
 * control flow. It will be thus represented as a singled node in 
 * the CFG.
 * 
 * Why not 'Assign of var * expr' to simplify even more ? Because
 * an expression like $a[2] = 3; would be forced to be linearized into
 * $xxx_1 = $a[2]; $xxx_1 = 3; which depending on the semantic of
 * assignement could be wrong (for instance with copy-on-write semantic).
 * 
 * Right now even pure expressions or function calls where we don't
 * store the return value are convereted in assignements or call
 * where we store the return value. We could have a 'Call of lvalue option ...'
 * and and 'PureExpr of expr', but it complicates things. The current scheme
 * may lead to many dead variables, but all those variables can be detected as
 * they will be tagged as fake variables anyway.
 *)
type instr = 
  | Assign of lvalue * assign_kind * expr
  | AssignRef of lvalue * lvalue
  | Call   of lvalue * call_kind * argument list
  | Eval of expr
  (* todo: Lambda *)

  (* Infix and Posfix exprs are desugared into regular assigns *)
  and assign_kind = 
    | AssignEq
    | AssignOp of assignOp
    (* todo: AssignList, AssignNew, Empty? *)

  and call_kind = 
    | SimpleCall        of name
    | StaticMethodCall  of qualifier * name
    | MethodCall        of var * name
    | DynamicCall       of qualifier option * var
    | DynamicMethodCall of var * var

    | New of class_name_reference 
    (* todo: Clone *)

   and argument = 
     | Arg of expr
     | ArgRef of lvalue

 (* with tarzan *)

(* Quite similar to Ast_php.stmt, except if/while/... contain the new
 * 'expr' type which are side-effect free. Also removed
 * some sugar and some deprecated forms like the ColonXxx.
 * Note that the include/require, which were removed from the 'expr'
 * are also not represented in 'stmt'. It's just bad coding. They should
 * be only at the toplevel.
 * 
 *)
type stmt = 
  | Instr of instr

  (* Could make If takes a stmt list instead of a stmt, which would remove
   * the need for Block. Not sure what is best. *)
  | Block of stmt list

  (* useful to avoid having some 'stmt option' for instance in If *)
  | EmptyStmt 

  (* elseifs are desugared; Switch are transformed in ifs *)
  | If of expr * stmt * stmt
  
  (* Do, For, Foreach are desugared  *)
  | While of expr * stmt

  (* todo: could transform that into gotos ? *)
  | Break of expr option
  | Continue of expr option

  | Return of expr option

  | Throw of expr
  | Try of stmt * catch

  (* InlineHtml is desugared *)
  | Echo of expr list

  (* todo? put expr stuff here (Print, Exit, Backquote, etc) 
   * todo? Globals, StaticVars,  Use, Unset, Declare ?
  *)

 and catch = unit (* TODO *)
  (* with tarzan *)

(*****************************************************************************)
(* Meta *)
(*****************************************************************************)

(* I wish I had deriving Show in OCaml ... in the mean time I have
 * to use my ocamltarzan tool to do compile-time reflection.
 *)

(* generated by ocamltarzan: ocamltarzan -vof pil.ml *)
let vof_dname = Meta_ast_php.vof_dname
let vof_name = Meta_ast_php.vof_name
let vof_qualifier = Meta_ast_php.vof_qualifier

let vof_indirect = Meta_ast_php.vof_indirect
let vof_binaryOp = Meta_ast_php.vof_binaryOp
let vof_unaryOp = Meta_ast_php.vof_unaryOp
let vof_assignOp = Meta_ast_php.vof_assignOp
let vof_castOp = Meta_ast_php.vof_castOp

let vof_constant = Meta_ast_php.vof_constant
let vof_class_name_reference = Meta_ast_php.vof_class_name_reference

let vof_phptype x = Ocaml.VTODO "type"

let vof_type_info { t = v_t } =
  let bnds = [] in
  let arg = vof_phptype v_t in
  let bnd = ("t", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds


let vof_var =
  function
  | Var v1 -> let v1 = vof_dname v1 in Ocaml.VSum (("Var", [ v1 ]))
  | This v1 -> let v1 = Meta_ast_php.vof_tok v1 in Ocaml.VSum (("This", [ v1 ]))
  
let rec vof_lvalue (v1, v2) =
  let v1 = vof_lvaluebis v1
  and v2 = vof_type_info v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_lvaluebis =
  function
  | VVar v1 -> let v1 = vof_var v1 in Ocaml.VSum (("VVar", [ v1 ]))
  | VQualifier ((v1, v2)) ->
      let v1 = vof_qualifier v1
      and v2 = vof_var v2
      in Ocaml.VSum (("VQualifier", [ v1; v2 ]))
  | ArrayAccess ((v1, v2)) ->
      let v1 = vof_var v1
      and v2 = Ocaml.vof_option vof_expr v2
      in Ocaml.VSum (("ArrayAccess", [ v1; v2 ]))
  | ObjAccess ((v1, v2)) ->
      let v1 = vof_var v1
      and v2 = vof_name v2
      in Ocaml.VSum (("ObjAccess", [ v1; v2 ]))
  | DynamicObjAccess ((v1, v2)) ->
      let v1 = vof_var v1
      and v2 = vof_var v2
      in Ocaml.VSum (("DynamicObjAccess", [ v1; v2 ]))
  | IndirectAccess ((v2, v1)) ->
      let v1 = vof_indirect v1
      and v2 = vof_var v2
      in Ocaml.VSum (("IndirectAccess", [ v2; v1 ]))
and vof_expr (v1, v2) =
  let v1 = vof_exprbis v1
  and v2 = vof_type_info v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_exprbis =
  function
  | Lv v1 -> let v1 = vof_lvalue v1 in Ocaml.VSum (("Lv", [ v1 ]))
  | C v1 ->
      let v1 = vof_constant v1 in Ocaml.VSum (("C", [ v1 ]))
  | Binary ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_binaryOp v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("Binary", [ v1; v2; v3 ]))
  | Unary ((v1, v2)) ->
      let v1 = vof_unaryOp v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Unary", [ v1; v2 ]))
  | CondExpr ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_expr v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("CondExpr", [ v1; v2; v3 ]))
  | ConsArray v1 ->
      let v1 = Ocaml.vof_list vof_expr v1
      in Ocaml.VSum (("ConsArray", [ v1 ]))
  | ConsHash v1 -> 
      let v1 = Ocaml.vof_list 
               (fun (e2, e3) ->
                  let v2 = vof_expr e2
                  and v3 = vof_expr e3 in
                Ocaml.VTuple [ v2; v3 ]) v1
      in Ocaml.VSum (("ConsHash", [ v1 ]))
  | Cast ((v1, v2)) ->
      let v1 = vof_castOp v1
      and v2 = vof_expr v2
      in Ocaml.VSum (("Cast", [ v1; v2 ]))
  | InstanceOf ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_class_name_reference v2
      in Ocaml.VSum (("InstanceOf", [ v1; v2 ]))
  
let rec vof_instr =
  function
  | Assign ((v1, v2, v3)) ->
      let v1 = vof_lvalue v1
      and v2 = vof_assign_kind v2
      and v3 = vof_expr v3
      in Ocaml.VSum (("Assign", [ v1; v2; v3 ]))
  | AssignRef ((v1, v2)) ->
      let v1 = vof_lvalue v1
      and v2 = vof_lvalue v2
      in Ocaml.VSum (("AssignRef", [ v1; v2 ]))
  | Call ((v1, v2, v3)) ->
      let v1 = vof_lvalue v1
      and v2 = vof_call_kind v2
      and v3 = Ocaml.vof_list vof_argument v3
      in Ocaml.VSum (("Call", [ v1; v2; v3 ]))
  | Eval v1 -> let v1 = vof_expr v1 in Ocaml.VSum (("Eval", [ v1 ]))
and vof_assign_kind =
  function
  | AssignEq -> Ocaml.VSum (("AssignEq", []))
  | AssignOp v1 ->
      let v1 = vof_assignOp v1 in Ocaml.VSum (("AssignOp", [ v1 ]))
and vof_call_kind =
  function
  | SimpleCall v1 ->
      let v1 = vof_name v1 in Ocaml.VSum (("SimpleCall", [ v1 ]))
  | StaticMethodCall ((v1, v2)) ->
      let v1 = vof_qualifier v1
      and v2 = vof_name v2
      in Ocaml.VSum (("StaticMethodCall", [ v1; v2 ]))
  | MethodCall ((v1, v2)) ->
      let v1 = vof_var v1
      and v2 = vof_name v2
      in Ocaml.VSum (("MethodCall", [ v1; v2 ]))
  | DynamicCall ((v1, v2)) ->
      let v1 = Ocaml.vof_option vof_qualifier v1
      and v2 = vof_var v2
      in Ocaml.VSum (("DynamicCall", [ v1; v2 ]))
  | DynamicMethodCall ((v1, v2)) ->
      let v1 = vof_var v1
      and v2 = vof_var v2
      in Ocaml.VSum (("DynamicMethodCall", [ v1; v2 ]))
  | New v1 ->
      let v1 = vof_class_name_reference v1 in Ocaml.VSum (("New", [ v1 ]))
and vof_argument =
  function
  | Arg v1 -> let v1 = vof_expr v1 in Ocaml.VSum (("Arg", [ v1 ]))
  | ArgRef v1 -> let v1 = vof_lvalue v1 in Ocaml.VSum (("ArgRef", [ v1 ]))
  
let rec vof_stmt =
  function
  | Instr v1 -> let v1 = vof_instr v1 in Ocaml.VSum (("Instr", [ v1 ]))
  | Block v1 ->
      let v1 = Ocaml.vof_list vof_stmt v1 in Ocaml.VSum (("Block", [ v1 ]))
  | EmptyStmt -> Ocaml.VSum (("EmptyStmt", []))
  | If ((v1, v2, v3)) ->
      let v1 = vof_expr v1
      and v2 = vof_stmt v2
      and v3 = vof_stmt v3
      in Ocaml.VSum (("If", [ v1; v2; v3 ]))
  | While ((v1, v2)) ->
      let v1 = vof_expr v1
      and v2 = vof_stmt v2
      in Ocaml.VSum (("While", [ v1; v2 ]))
  | Break v1 ->
      let v1 = Ocaml.vof_option vof_expr v1 in Ocaml.VSum (("Break", [ v1 ]))
  | Continue v1 ->
      let v1 = Ocaml.vof_option vof_expr v1
      in Ocaml.VSum (("Continue", [ v1 ]))
  | Return v1 ->
      let v1 = Ocaml.vof_option vof_expr v1
      in Ocaml.VSum (("Return", [ v1 ]))
  | Throw v1 -> let v1 = vof_expr v1 in Ocaml.VSum (("Throw", [ v1 ]))
  | Try ((v1, v2)) ->
      let v1 = vof_stmt v1
      and v2 = vof_catch v2
      in Ocaml.VSum (("Try", [ v1; v2 ]))
  | Echo v1 ->
      let v1 = Ocaml.vof_list vof_expr v1 in Ocaml.VSum (("Echo", [ v1 ]))
and vof_catch v = Ocaml.vof_unit v

(*****************************************************************************)
(* String of *)
(*****************************************************************************)

let (adjust_ocaml_v: ?show_all:bool -> Ocaml.v -> Ocaml.v) =
 fun ?(show_all=false) v ->

  let v = 
    if show_all
    then v
    else 
      (* let's hide all those {pinfo = ... } and types annotations *)
      Ocaml.map_v ~f:(fun ~k v ->
        match v with
        | Ocaml.VDict xs ->
            if xs +> List.exists (fun (s, _) -> List.mem s ["pinfo"; "t"])
            then
              Ocaml.VDict []
            else k v
        | _ -> k v
      ) v
  in
  v

let (string_of_instr: ?show_all:bool -> instr -> string) = 
 fun ?show_all x ->
  x +> vof_instr +> adjust_ocaml_v ?show_all +> Ocaml.string_of_v

let string_of_stmt ?show_all x = 
  x +> vof_stmt +> adjust_ocaml_v ?show_all +> Ocaml.string_of_v

let string_of_expr ?show_all x = 
  x +> vof_expr +> adjust_ocaml_v ?show_all +> Ocaml.string_of_v


@

<<pil_build.ml>>=
<<Facebook copyright>>

open Common 

open Ast_php

module Ast = Ast_php

module A = Ast_php
module B = Pil

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(* The goal of this module is to transform constructs from Ast_php to
 * the simpler constructs of Pil. Here are the simplifications done:
 * 
 * - linearization of expression
 * - sugar removing for increments
 * - removing tokens from the AST, to have really an AST, not a CST
 * - TODO many other stuff
 *)
(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
let noType () = ({ B.t = [Type_php.Unknown] })

(* We don't propagate the tainting as the typing inference will
 * be done on the simplified AST (PIL) rather than on the original
 * AST *)
let mkt x = x, noType ()

let counter = ref 0
let fresh_var () = 
  incr counter;
  let s = spf "F_%d" !counter in
  B.Var (A.DName (s, Ast.fakeInfo s))

let vv_of_v v=
  mkt (B.VVar v)

let fresh_vvar () = 
  vv_of_v (fresh_var ())

let expr_of_int i =
  mkt(B.C(A.Int(string_of_int i, A.fakeInfo (string_of_int i))))

let expr_true () =
  mkt(B.C(A.CName(A.Name("true", A.fakeInfo "true"))))
let expr_false () =
  mkt(B.C(A.CName(A.Name("false", A.fakeInfo "false"))))


let stmt_of_stmts_list = function
| [] -> B.EmptyStmt
| [ stmt ] -> stmt
| l -> B.Block l

(*****************************************************************************)
(* Algorithm *)
(*****************************************************************************)

(*****************************************************************************)
(* Main entry point *)
(*****************************************************************************)

(* ------------------------------------------------------------------------- *)
(* Expressions *)
(* ------------------------------------------------------------------------- *)

let (linearize_expr: A.expr -> B.instr list * B.expr) = fun e ->

  let instrs = ref [] in

  let rec (aux_lvalue: A.lvalue -> B.lvalue) = fun v ->
    match Ast.untype v with
    | A.Var (dname, _scoperef) -> mkt (B.VVar (B.Var dname))

    | A.FunCallSimple (name, argsA) ->
        let argsB = argsA |> Ast.unparen |> Ast.uncomma |> aux_args in
        let v = make_var_from_call (B.SimpleCall name) argsB in
        vv_of_v v

    | A.ObjAccessSimple (obj, _, name) ->
        let v = make_var_from_Alvalue obj in
        mkt (B.ObjAccess(v, name))

    | A.MethodCallSimple (obj, _, name, argsA) ->
        let v_obj = make_var_from_Alvalue obj in
        let argsB = argsA |> Ast.unparen |> Ast.uncomma |> aux_args in
        let v = make_var_from_call (B.MethodCall(v_obj, name)) argsB in
        vv_of_v v

    | A.StaticMethodCallSimple (qualif, name, argsA) ->
        let argsB = argsA |> Ast.unparen |> Ast.uncomma |> aux_args in
        let v = make_var_from_call (B.StaticMethodCall(qualif, name)) argsB in
        vv_of_v v

    | A.ObjAccess (obj, (_, obj_prop, argsA_opt)) ->
        let v_obj = make_var_from_Alvalue obj in
        (match obj_prop, argsA_opt with
         | ObjPropVar(att), None ->
            (* example: $obj->$att=3 *)
            let v_att = make_var_from_Alvalue att in
            mkt(B.DynamicObjAccess(v_obj, v_att))
         | ObjPropVar(att), Some argsA ->
            let v_att = make_var_from_Alvalue att in
            let argsB = argsA |> Ast.unparen |> Ast.uncomma |> aux_args in
            let v = make_var_from_call 
                    (B.DynamicMethodCall(v_obj, v_att)) argsB in
            vv_of_v v
         | ObjProp(obj_dim), _ ->
            (* for this case we need a special recursive function
             * since an obj_dim can contain another obj_dim *)
             let argsB_opt = 
               argsA_opt |> Common.map_option 
                 (fun args -> args |> Ast.unparen |>
                                Ast.uncomma |> aux_args) in
               lv_of_obj_dim v_obj obj_dim argsB_opt
        )

    | A.FunCallVar (qualif_opt, func, argsA) ->
        let v_func = make_var_from_Alvalue func in
        let argsB = argsA |> Ast.unparen |> Ast.uncomma |> aux_args in
        let v_res =
          (* TODO: can do better than a dynamic call *)
          make_var_from_call
          (B.DynamicCall(qualif_opt, v_func)) argsB in
        vv_of_v v_res

    | A.VQualifier(qualif, lv) ->
        let v = make_var_from_Alvalue lv in
        mkt (B.VQualifier(qualif, v))

    | A.This t -> mkt (B.VVar (B.This t))

    | A.VArrayAccess(lvA, e) ->
        (* we need to pass by reference because of the case:
         * $a[1][2]=3;
         * $b=$a[1];
         * var_dump($b); // 3
         * $b[2]=0;
         * var_dump($b); // 0
         * var_dump($a); // still 3!! Because of copy on write
         *)
        let lvB = aux_lvalue lvA in
        let v = fresh_var() in
        let vv = vv_of_v v in
        let instr = B.AssignRef(vv, lvB) in
        Common.push2 instr instrs;
        let expr = Common.map_option aux_expr (unbracket e) in
        mkt (B.ArrayAccess(v, expr))

    | A.VBraceAccess(lv, e_brace) ->
        let t1, e, t2 = e_brace in
        let e_bracket_opt = t1, Some(e), t2 in
        aux_lvalue (A.VArrayAccess(lv, e_bracket_opt), snd v)

    | A.Indirect(lv, indir) ->
        let v = make_var_from_Alvalue lv in
        mkt (B.IndirectAccess(v, indir))

    | A.VBrace(_, e_brace) ->
        let e = A.unbrace e_brace in
        make_var_from_Aexpr e |> vv_of_v

  and aux_args args = 
    args +> List.map (function
    | A.Arg e -> 
        let e = aux_expr e in
        B.Arg e
    | A.ArgRef (_tok, var) ->
        let lv = aux_lvalue var in
        B.ArgRef lv
    )

  and aux_expr e = 
      match Ast.untype e with
      | A.Lv v -> 
          let v = aux_lvalue v in
          mkt (B.Lv v)
      | A.Assign (v, _tok, e) ->
          let v = aux_lvalue v in
          let e = aux_expr e in
          let instr = B.Assign (v, B.AssignEq, e) in
          Common.push2 instr instrs;
          mkt (B.Lv v)
      | A.Binary (e1, (op, _wrap), e2) ->
          let e1 = aux_expr e1 in
          let e2 = aux_expr e2 in
          mkt (B.Binary (e1, op, e2))

      | A.Unary (op, eA) ->
          let eB = aux_expr eA in
          mkt (B.Unary(A.unwrap op, eB))

      | A.Sc sc ->
          (match sc with
          | A.C cst ->
              mkt (B.C cst)
          | A.ClassConstant (q, n) ->
              mkt (B.ClassConstant (q, n))
          | (HereDoc (_, _, _)|Guil (_, _, _)) ->
              raise Todo
          )

      | A.ConsArray (_tok, array_pairs) ->
          (* TODOjjeannin: for the cases ArrayRef and ArrayArrowRef
           * the translation is semantically wrong, but it's good enough
           * for type inference and control flow analysis *)
          (* For mixed arrows/not arrows arrays, the following example 
           * gives a good idea of the semantics:
           php> var_dump(array(1,"car"=>2,3,"bus"=>4,5));
           array(5) {
             [0]=>
             int(1)
             ["car"]=>
             int(2)
             [1]=>
             int(3)
             ["bus"]=>
             int(4)
             [2]=>
             int(5)
           }
           *)
          let array_pairs = array_pairs +> Ast.unparen +> Ast.uncomma in

          if array_pairs +> List.exists (function
          | A.ArrayArrowExpr _ | A.ArrayArrowRef _ -> true
          | _ -> false
          ) 
          then
            let i = ref 0 (* next index in the array *) in
            let exprs = 
              array_pairs +> List.map (function
              | A.ArrayExpr e -> 
                  let res = expr_of_int !i, aux_expr e in
                    i:= !i+1; res
              | A.ArrayArrowExpr (e1, _, e2) ->
                  aux_expr e1, aux_expr e2
         (* the last two cases are semantically wrong (I'm suppressing &) *)
              | A.ArrayRef (_, lv) ->
                  let res = expr_of_int !i, mkt(B.Lv(aux_lvalue lv)) in
                    i:= !i+1; res
              | A.ArrayArrowRef (e1, _, _, lv2) ->
                  aux_expr e1, mkt(B.Lv(aux_lvalue lv2))
              )
            in mkt (B.ConsHash exprs)
          else
            let exprs =
              array_pairs +> List.map (function
              | A.ArrayExpr e -> aux_expr e
              | A.ArrayRef(_, lA) -> (* semantically wrong *)
                  let lB = aux_lvalue lA in
                  mkt(B.Lv lB)
              | _ -> raise Impossible
              )
            in mkt (B.ConsArray exprs)

      | A.ParenExpr e_paren ->
          e_paren |> A.unparen |> aux_expr

      | A.Eval(_, e_paren) -> (* TODOjjeannin *)
          (*let v = e_paren |> A.unparen |> make_var_from_Aexpr in
          mkt (B.Lv( vv_of_v v))*) raise Todo

      | A.AssignOp(lvA, op_w, eA) ->
          let lvB = aux_lvalue lvA in
          let eB = aux_expr eA in
          let instr = B.Assign (lvB, B.AssignOp(A.unwrap op_w), eB) in
          Common.push2 instr instrs;
          mkt (B.Lv lvB)

      | A.Cast (c, e) ->
          mkt (B.Cast (A.unwrap c, aux_expr e))

      | A.CondExpr(cond, _, if_t, _, if_f) ->
          mkt (B.CondExpr(aux_expr cond, aux_expr if_t, aux_expr if_f))

      | A.EDots _ -> raise Impossible
      | A.Lambda _ -> raise Todo

      | A.Isset (t, argsA) ->
          (* for now we transform it into a normal function call ; TODO *)
          (* this is wrong because the argument is going to be evaluated *)
          let argsB = argsA |> A.unparen |> A.uncomma |>
                      (List.map (fun a -> B.Arg(mkt(B.Lv( aux_lvalue a))))) in
          let v = make_var_from_call 
                    (B.SimpleCall (Name("isset", A.fakeInfo "isset"))) argsB in
          mkt (B.Lv (vv_of_v v))

      | A.Print (t, e) ->
          (* we transform it into a normal function call *)
          let v = make_var_from_call (B.SimpleCall 
                                        (Name("print", A.fakeInfo "print"))) 
                    [ B.Arg(aux_expr e) ] in
          mkt (B.Lv (vv_of_v v))

      | A.Empty (t, lv) ->
          (* we transform it into a normal function call *)
          let v = make_var_from_call (
            B.SimpleCall (Name("empty", A.fakeInfo "empty"))) 
                    [ B.Arg(mkt(B.Lv(aux_lvalue(A.unparen lv)))) ] in
          mkt (B.Lv (vv_of_v v))

      | A.New(_, cnr, args_opt) ->
          (* if args_opt is None I call a function with an empty list
           * not sure that's right *)
          let v = make_var_from_call
                (B.New cnr)
                (match args_opt with 
                   |None -> [] 
                   |Some(args)-> args |> A.unparen |> A.uncomma |> aux_args) 
          in
          mkt (B.Lv (vv_of_v v))

      | A.AssignNew(lvA, _, _, _, cnr, args_opt) -> 
          let lvB = aux_lvalue lvA in
          let argsB =
            (match args_opt with 
               |None -> [] 
               |Some(argsA)-> argsA |> A.unparen |> A.uncomma |> aux_args) in
          let instr = B.Call (lvB, B.New cnr, argsB) in
          Common.push2 instr instrs;
          mkt (B.Lv lvB)

      | A.At(_, expr) ->
          (* TODO: for now we just suppress the @ signs *)
          aux_expr expr

      | A.InstanceOf(expr, _, cnr) ->
          mkt(B.InstanceOf(aux_expr expr, cnr))

      | A.XhpHtml _ -> raise Todo

      | A.Infix(op_w, lvA) | A.Postfix(lvA, op_w) ->
          (* ++lv returns the final value of lv
           * lv++ returns the initial value of lv
           *
           * For any context C[.] :
           * C[++lv] should be translated as 
           * lv=lv+1; fresh=lv; C[lv] 
           * because lv might be changed again in the context C 
           *
           * C[lv++] should be translated as
           * fresh=lv; lv=lv+1; C[lv]
           *)
          let binop = Arith(
            match A.unwrap op_w with Dec -> Plus | Inc -> Minus) in
          let lvB = aux_lvalue lvA in
          let instr = B.Assign(lvB, B.AssignEq, 
                      mkt(B.Binary(mkt(B.Lv(lvB)), binop, 
                                   expr_of_int 1))) in
          let fresh =
          (match Ast.untype e with 
           | A.Infix(_,_) -> 
               Common.push2 instr instrs; (* pushing lv=lv+1 *)
               make_var_from_Blvalue lvB        
                   (* creating and pushing fresh=lv *)
           | A.Postfix(_,_) ->
               let fresh0 = make_var_from_Blvalue lvB in 
                   (* creating/push fresh=lv *)
               Common.push2 instr instrs;         (* pushing lv=lv+1 *)
               fresh0
           | _ -> raise Impossible
          ) in mkt (B.Lv (vv_of_v fresh))  (* call to fresh inside context *)

      | A.AssignRef(lv1, _, _, lv2) ->
          let lv1B = aux_lvalue lv1 in
          let lv2B = aux_lvalue lv2 in
          let instr = B.AssignRef (lv1B, lv2B) in
          Common.push2 instr instrs;
          mkt (B.Lv lv1B)

      | (RequireOnce (_, _)|Require (_, _)|IncludeOnce (_, _)|Include (_, _))
        -> failwith "Those should be lifted by another simplification phase"

      | A.AssignList(_, la, _, expr) ->
          (* list($la1, $la2, ..., $lan) = expr has to be translated as 
           * $fresh = expr; $la1 = fresh[1]; 
           * $la2 = fresh[2]; ...; $la<n> = fresh[n]; $fresh
           * if $la<i> is a list itself list($la<i>1, ..., $la<i>m), 
           * we need to replace the instruction
           * $la<i>=fresh by the instrucions:
           * $la<i>1 = fresh[i][1]; ...; $la<i>m = fresh[i][m]
           * and so on recursively *)
          let fresh = make_var_from_Aexpr expr in (* $fresh = expr *)
          push_list_assign la fresh;
          mkt(B.Lv(vv_of_v fresh))

      | A.Exit (_, args) -> raise Todo
      |A.BackQuote (_, _, _)|A.CastUnset (_, _)|A.Clone (_, _)
        -> raise Todo
    
  (* Helper functions for converting lvalues, expressions and calls into
   * variables; their use ensures that we never forget the Common.push2 *)
  and (make_var_from_Blvalue: B.lvalue -> B.var) = fun lvB ->
    let v = fresh_var() in
    let vv = mkt (B.VVar v) in
    let instr = B.Assign (vv, B.AssignEq, mkt (B.Lv lvB)) in
    Common.push2 instr instrs;
    v

  and (make_var_from_Alvalue: A.lvalue -> B.var) = fun lvA ->
    let (lvB: B.lvalue) = aux_lvalue lvA in 
    make_var_from_Blvalue lvB

  and (make_var_from_Bexpr: B.expr -> B.var) = fun eB ->
    let v = fresh_var () in
    let vv = mkt (B.VVar v) in
    let instr = B.Assign (vv, B.AssignEq, eB) in
    Common.push2 instr instrs;
    v

  and (make_var_from_Aexpr: A.expr -> B.var) = fun eA ->
    let (eB: B.expr) = aux_expr eA in
    make_var_from_Bexpr eB

  and (make_var_from_call: B.call_kind -> B.argument list -> B.var) = 
    fun ck args ->
    let v = fresh_var() in
    let instr = B.Call (vv_of_v v, ck, args) in
    Common.push2 instr instrs;
    v

  and (lv_of_obj_dim: 
         B.var -> A.obj_dim -> B.argument list option -> B.lvalue) = 
    fun v_obj obj_dim argsB_opt -> 
      match obj_dim with
      (* TODOjjeannin: better explanation of what's going on
       * var_of_obj_dim obj_var obj_dim args translates
       * $obj_var->obj_dim(args), i.e. in the AST of PHP
       * ObjAccess(Var($obj_var), ObjProp(obj_dim))
       * where $obj_var is a variable for the object that has been
       * created previously *)
    | OName(name) -> 
        (match argsB_opt with
          | None -> mkt(B.ObjAccess(v_obj, name))
          | Some(argsB) ->
              let v = make_var_from_call
                      (B.MethodCall(v_obj, name)) argsB in
              vv_of_v v
        )
    | OBrace (e_brace) ->
        (* example: $obj->{expr}=3; or $obj->{expr}(args)=3; *)
        begin
          let e = A.unbrace e_brace in
          match argsB_opt with
          | None ->  mkt(B.DynamicObjAccess(v_obj, make_var_from_Aexpr e))
          | Some(argsB) -> 
              let v = make_var_from_call 
              (B.DynamicMethodCall(v_obj, make_var_from_Aexpr e)) argsB in
              vv_of_v v
        end
    | OArrayAccess (od, e_brace) -> 
        (* example: $obj->att[1]=3 or $obj->att[1](args)=3; *)        
        let lv_od = lv_of_obj_dim v_obj od None in
        let v_od = make_var_from_Blvalue lv_od in
        let e = e_brace |> A.unbracket |> (Common.map_option aux_expr) in
        let v = make_var_from_Blvalue (mkt(B.ArrayAccess(v_od, e))) in
        begin 
          match argsB_opt with
          | None -> vv_of_v v 
          | Some(argsB) ->
              let v2 = make_var_from_call
                       (B.DynamicCall(None, v)) argsB in
              vv_of_v v2
        end
    | OBraceAccess (od, e_brace) ->
        (* example: $obj->att{1}=3; or $obj->att{1}(args)=3; *)
        (* the semantic of { } in that case is exactly the same as [ ] *)
        let t1, e, t2 = e_brace in
        let e_bracket_opt = t1, Some(e), t2 in
        lv_of_obj_dim v_obj (A.OArrayAccess(od, e_bracket_opt)) argsB_opt

  and (push_list_assign :
         A.list_assign A.comma_list A.paren -> B.var -> unit)
          (* (push_list_assign list(la1, ..., lan) var) pushes on instrs
           * the assignments la1=var[1]; ...; la2=var[2]
           * needs to be called recursively if some la<i> is itself
           * a list(la<i>1, ..., la<i>m) *)
       = fun la_cp var -> 
         let i = ref 0 in (* counter in the list, starts at 0 *)
         la_cp |> A.unparen |> A.uncomma |> List.iter
           ( function
             | ListVar(lvA) ->
                 let lvB = aux_lvalue lvA in
                 (* $lvB = $var[i] *) 
                 let instr = B.Assign(
                   lvB, B.AssignEq,
                   mkt(B.Lv(mkt(B.ArrayAccess(var,
                       Some(expr_of_int !i)))))) in
                 i:= !i+1;
                 Common.push2 instr instrs
             | ListEmpty -> i:= !i+1
             | ListList(_, la2)->
                 (* needs an assignment by reference
                  * to see why, see the A.VArrayAccess case *)
                 (* $var2 =& $var[i]
                  * then recursive call *)
                 let lvB = 
                   B.ArrayAccess(var,
                                 Some(expr_of_int !i))
                 in
                 i:= !i+1;
                 let var2 = fresh_var() in
                 let instr = B.AssignRef(vv_of_v var2, mkt lvB) in
                 Common.push2 instr instrs;
                 push_list_assign la2 var2
           )

  in
  let last_expr = aux_expr e in

  List.rev (!instrs), last_expr
  
(* ------------------------------------------------------------------------- *)
(* Statements *)
(* ------------------------------------------------------------------------- *)

let instrs_to_stmts xs = 
  xs +> List.map (fun x -> B.Instr x)

let (linearize_stmt: Ast_php.stmt -> Pil.stmt list) = fun st ->

  let rec (aux_stmt : A.stmt -> B.stmt list) = fun st ->
    match st with
    | A.ExprStmt (e, _tok) ->
        (* todo? print warning of _last_expr is not
         * a simple Lv ? 
         *)
        let instrs, _last_expr = linearize_expr e in
        instrs_to_stmts instrs

    | A.Block stmt_and_defs ->
        let xs = Ast.unbrace stmt_and_defs in
        xs +> List.map aux_stmt_and_def +> List.flatten

    | A.Echo (_, exprs, _) ->
        let exprs = Ast.uncomma exprs in

        let xs = List.map linearize_expr exprs in
        let all_instrs = List.map fst xs +> List.flatten in
        let all_expr = List.map snd xs in
        
        instrs_to_stmts all_instrs ++ [B.Echo all_expr]

    | A.Return (_, eopt, _) ->
        (* todo: should be more readable, a monad or fmap_xxx *)
        let eopt, instrs = 
          match eopt with
          | None -> None, []
          | Some e -> 
              let instrs, last_expr = linearize_expr e in
              Some last_expr, instrs
        in
        instrs_to_stmts instrs ++ [B.Return eopt]

    | A.While (_tok, expr, colon_stmt) ->
        let expr = Ast.unparen expr in
        let instrs, last_expr = linearize_expr expr in
        let setup_expr_stmts = instrs_to_stmts instrs in

        let stmts = aux_colon_stmt colon_stmt in
        setup_expr_stmts ++ [B.While (last_expr, 
                                     B.Block (stmts ++ setup_expr_stmts))]

    | A.Do(_, stmt, _, expr, _) ->
        (* do{ A } while (b) is translated as
         * $fresh = true; while($fresh) do { A; $fresh = b }
         *)
        let expr = Ast.unparen expr in
        let stmts = aux_stmt stmt in

        let instrs, last_expr = linearize_expr expr in
        let setup_expr_stmts = instrs_to_stmts instrs in
        
        let fresh = fresh_vvar() in
        let fresh_true = B.Instr(B.Assign(fresh, B.AssignEq, expr_true()))
        (* $fresh = true *) in
        let fresh_b = B.Instr(B.Assign(fresh, B.AssignEq, last_expr))
                        (* $fresh = b *) in
        [ fresh_true ] ++ [ B.While (mkt(B.Lv(fresh)),
          B.Block(stmts ++ setup_expr_stmts ++ [fresh_b])) ]

    | A.For(_, _, initA, _, condA, _, incrA, _, stmtA) -> 
        (* for(init1, ..., initk; cond1, ..., condm; incr1, ..., incrn)
         * { stmt } is translated as
         * init1; ...; initk; cond1; ...; cond<m-1>; while(condm) 
         * { stmt; incr1; ...; incrn ; cond1; ...; cond<m-1> }
         * see http://php.net/manual/en/control-structures.for.php
         *)        let rec (list_to_expr_cond : 
           (B.instr list * B.expr) list -> B.instr list * B.expr) = function
        (* from a list [instrs1,expr1;...;instrsn,exprn]
         * builds the pair
         * [instrs1; expr1; instrs2... instrs<n-1>; expr<n-1>; instrsn], exprn
         *)
         | [] -> [], expr_true()
         | [instrs, expr] -> instrs, expr
         | (instrs, expr)::tl -> 
             let instrs_tl, expr_tl = list_to_expr_cond tl in
             instrs ++ [B.Eval(expr)] ++ instrs_tl, expr_tl
        in let rec (flatten_instrs :
            (B.instr list * B.expr) list -> B.instr list) = function
        (* from a list [instr1,expr1;...;instrn,exprn]
         * builds the list
         * [instr1; expr1; instr2... instr<n-1>; expr<n-1>; instrn; exprn ]
         *)
         | [] -> []
         | (instrs, expr)::tl ->
             let instrs_tl = flatten_instrs tl in
             instrs ++ [B.Eval(expr)] ++ instrs_tl
        in
        let init_stmts = initA |> A.uncomma |> List.map linearize_expr
          |> flatten_instrs |> instrs_to_stmts
        and cond_instrs, cond = condA |> A.uncomma 
          |> List.map linearize_expr |> list_to_expr_cond
        and incr_stmts = incrA |> A.uncomma |> List.map linearize_expr
          |> flatten_instrs |> instrs_to_stmts
        and stmtB = aux_colon_stmt stmtA in
        let cond_stmts = cond_instrs |> instrs_to_stmts in
          init_stmts ++ cond_stmts ++ 
          [ B.While(cond, B.Block( stmtB ++ incr_stmts ++ cond_stmts )) ]

    | A.Foreach(_, _, expr, _, lv, arr, _, stmt) -> raise Todo
        (* foreach($arr as $value){stmt} is translated as
         * while(list(, $value) = each($arr)){stmt}, i.e.
         *
         *
         * foreach($arr as $key => $value){stmt} is translated as
         * while(list($key, $value) = each($arr)){stmt}, i.e.
         *)
        (* According to Drew from HPHP, this will not work
         * as the each construct uses an internal temp variable
         * so if we translate like this any nested foreach loop
         * will have the wrong semantics; still according to him
         * foreach cannot be translated only using the construcs of PIL *)

    | A.If (tok, cond1, stmt1, elseifs, elseopt) ->
        (* if(a){b}elseif(c){d}elseif(e){f}else{g} is translated in
         * if(a){b}else{if(c){d}else{if(e){f}{g}}} etc.
         *)
        (* there cannot be any break statements inside an if so 
         * that should not cause a problem *)
        let rec (aux : (tok * A.expr paren * A.stmt) list ->
                   (tok * A.stmt) option -> B.stmt list)
                   = fun elseifs elseopt ->
        (match elseifs, elseopt with
        | [], None -> []
            
        | (_, condA, stmtA)::tl, elseopt ->
            let instrs_cond, expr_cond = condA |> Ast.unparen 
              |> linearize_expr in
            let stmts_cond = instrs_to_stmts instrs_cond in
            let stmtsB = aux_stmt stmtA in
            stmts_cond ++ [ B.If(expr_cond, B.Block stmtsB, 
                                 stmt_of_stmts_list (aux tl elseopt)) ]

        | [], Some (_, stmtA) -> aux_stmt stmtA

        ) in
        (* the if case is not any different than all the other
         * elseif cases; it just appears first *)
        aux ((tok, cond1, stmt1)::elseifs) elseopt

    | A.IfColon (tok1, cond1, tok2, stmt1, elseifs, elseopt, _, _) ->
        (* this is very similar to the A.If case;
         * it seems too complicated to do just one case for both though *)
        let rec (aux : A.new_elseif list ->
                   A.new_else option -> B.stmt list)
                   = fun elseifs elseopt ->
        (match elseifs, elseopt with
        | [], None -> []
            
        | (_, condA, _, stmtsA)::tl, elseopt ->
            let instrs_cond, expr_cond = condA |> Ast.unparen 
              |> linearize_expr in
            let stmts_cond = instrs_to_stmts instrs_cond in
            let stmtsB = stmtsA |>  List.map aux_stmt_and_def 
              |> List.flatten in
            stmts_cond ++ [ B.If(expr_cond, B.Block stmtsB, 
                                 stmt_of_stmts_list (aux tl elseopt)) ]

        | [], Some (_, _, stmtsA) -> 
            stmtsA |> List.map aux_stmt_and_def |> List.flatten

        ) in
        (* the if case is not any different than all the other
         * elseif cases; it just appears first *)
        aux ((tok1, cond1, tok2, stmt1)::elseifs) elseopt

    | A.Switch(_, exprA, switch_cases) ->
        (* This is a hard one, even if it does not look like it;
         * here is a way to translate it that should work:
         * switch(expr){
         *   case expr_a :
         *     do_a;
         *   case expr_b :
         *     do_b;
         *   ...
         *   default :
         *     do_default
         *   ...
         * }  
         *     is translated as:
         * $expr = expr;
         * $cond_while = true;
         * while($cond_while){
         *   $cond_while = false; // only goes through once
         *   $case = 0;
         *   if($expr == expr_a){ $case=1; }
         *   else if($expr == expr_b){ $case=2; }
         *   // b should not be evaluated if we are in the case a
         *   // (only relevant if b has side effects)
         *   ...
         *   // nothing here for default
         *   ...
         *   $cond = ($case == 1) || $cond;
         *   if($cond){ do_a; }
         *   $cond = ($case == 2) || $cond;
         *   if($cond){ do_b; }
         *   ...
         *   $cond = ($case == 0) || $cond; // 0 is for default
         *   if($cond){ do_d; }
         *   ...
         * }
         * The enclosing while($cond) is to make sure everything
         * works fine if there is a break instruction in the middle; we
         * could have done it with while(true){... ; break;} but our way
         * ensures it also works with continue instructions.
         * The two passes are necessary to ensure default behaves correctly:
         * expr_a, expr_b, are evaluated in order until one applies; if none
         * applies, default applies; if default applies all the expr_a,
         * expr_b, etc. have to be evaluated, even
         * if they are after the default. default only applies if no other
         * case applies, even if default is not at the end.
         *)  
        let instrs_expr, exprB = exprA |> Ast.unparen
          |> linearize_expr in
        let stmts_expr = instrs_to_stmts instrs_expr in
        let expr_vv = fresh_vvar ()
        and cond_while_vv = fresh_vvar ()
        and case_vv = fresh_vvar()
        and cond_vv = fresh_vvar()
        and i = ref 0 in (* counter of the cases *)
        let rec (aux : A.case list -> (B.stmt list)*(B.stmt list)) = function
          (* this generates the two series of if statements
           * if_stmt is what is to be included in the else branch
           * of the first serie *)
        | [] -> [], []
        | Case(_, eA, _, stmtA)::tl ->
            let instrs_eB, eB = linearize_expr eA in
            let stmts_eB = instrs_to_stmts instrs_eB
            and stmtB = stmtA |> (List.map aux_stmt_and_def)
                |> List.flatten |> stmt_of_stmts_list in
            let index = !i in i := !i+1;
            let l1, l2 = aux tl in
            ( stmts_eB ++ 
              [ B.If(mkt(B.Binary(mkt(B.Lv(expr_vv)), A.Logical A.Eq, eB)),
                     B.Instr(B.Assign(case_vv, B.AssignEq, 
                                      expr_of_int index)),
                     stmt_of_stmts_list l1) ]
            ), (
              B.Instr(B.Assign(cond_vv, B.AssignEq, 
                               mkt(B.Binary(mkt(B.Binary(mkt(B.Lv case_vv),
                                                         A.Logical A.Eq,
                                                         expr_of_int index)),
                                            A.Arith A.Or,
                                            mkt(B.Lv cond_vv))))) ::
              B.If(mkt(B.Lv cond_vv), stmtB, B.EmptyStmt) ::
              l2
            )
        | Default(_, _, stmtA)::tl ->            
            let stmtB = stmtA |> (List.map aux_stmt_and_def)
                |> List.flatten |> stmt_of_stmts_list in
            let l1, l2 = aux tl in
            l1, (
              B.Instr(B.Assign(cond_vv, B.AssignEq, 
                               mkt(B.Binary(mkt(B.Binary(mkt(B.Lv case_vv),
                                                         A.Logical A.Eq,
                                                         expr_of_int 0)),
                                            A.Arith A.Or,
                                            mkt(B.Lv cond_vv))))) ::
              B.If(mkt(B.Lv cond_vv), stmtB, B.EmptyStmt) ::
              l2
            ) in
        let cases = match switch_cases with
          | CaseList(_, _, c, _) | CaseColonList( _, _, c, _, _) -> c in
        let l1, l2 = aux cases in
        stmts_expr ++ 
        [ B.Instr(B.Assign(expr_vv, B.AssignEq, exprB))] ++
        [ B.Instr(B.Assign(cond_while_vv, B.AssignEq, expr_true())) ] ++
        [ B.While(mkt(B.Lv(cond_while_vv)), B.Block(
            [ B.Instr(B.Assign(cond_while_vv, B.AssignEq,expr_false())) ] ++
            [ B.Instr(B.Assign(case_vv, B.AssignEq, expr_of_int 0)) ] ++
            l1 ++ l2))
        ]

    | A.Break(_, None, _) -> [ B.Break None ]
    | A.Break(_, Some exprA, _) ->
        let instrs, expr = linearize_expr exprA in
        (instrs_to_stmts instrs) ++ [ B.Break (Some expr) ]
      
    | A.EmptyStmt _ -> [ ] (* or [ B.EmptyStmt ] ? *)

    | A.Continue(_, None, _) -> [ B.Continue None ]
    | A.Continue(_, Some exprA, _) ->
        let instrs, expr = linearize_expr exprA in
        (instrs_to_stmts instrs) ++ [ B.Continue (Some expr) ]

    | A.Throw(_, exprA, _) ->
        let instrs, expr = linearize_expr exprA in
        (instrs_to_stmts instrs) ++ [ B.Throw expr ]

    | A.Use _ ->
         failwith "This Use should be lifted by another simplification phase"

      |
(Declare (_, _, _)|Unset (_, _, _)|InlineHtml _|
StaticVars (_, _, _)|Globals (_, _, _)|Try (_, _, _, _))
        -> raise Todo

  and aux_colon_stmt colon = 
    match colon with
    | A.SingleStmt st -> aux_stmt st
    | A.ColonStmt(_, stl, _, _) -> stl |> List.map aux_stmt_and_def
      |> List.flatten
  and aux_stmt_and_def x = 
    match x with
    | A.Stmt st -> aux_stmt st
    | (InterfaceDefNested _|ClassDefNested _|FuncDefNested _) ->
        raise Todo
  in
  

  let stmts = aux_stmt st in
  stmts


let (linearize_body: Ast_php.stmt_and_def list -> Pil.stmt list) = fun xs ->
  xs +> List.map (fun x ->
    match x with
    | A.Stmt st -> linearize_stmt st
    | (InterfaceDefNested _|ClassDefNested _|FuncDefNested _) ->
        raise Todo
  ) +> List.flatten

@

