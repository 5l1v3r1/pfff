<<builtins_php.ml>>=
<<Facebook copyright>>

open Common 

open Ast_php

module Flag = Flag_analyze_php
module Ast = Ast_php

module V = Visitor_php

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(* 
 * As opposed to OCaml or C++ or Java or most programming languages, 
 * there is no source code files where PHP builtin functions
 * and their types are declared. They are defined in the PHP manual 
 * and somewhere in the source code of Zend.
 * In OCaml most library functions are written in OCaml itself or are specified
 * via an 'external' declaration as in:
 * 
 *   external (=) : 'a -> 'a -> bool = "%equal"
 * 
 * This is very convenient for certain tasks such as code browsing where
 * many functions would be seen as 'undefined' otherwise, or for 
 * the type inference  where we have info about the basic functions. 
 * 
 * Unfortunately, this is not the case for PHP. Fortunately the
 * good guys from HPHP have spent some time to specify in a IDL form 
 * the interface of many of those builtin PHP functions (including the 
 * one in some popular PHP extensions). They used it to 
 * generate C++ header files, but we can abuse it to instead generate
 * PHP "header" files that our tool can understand.
 * 
 * Moreover the PHP manual is stored in XML files and can also
 * be automatically processed to extract the names and types
 * of the builtin functions, classes, and constants.
 *)


(*****************************************************************************)
(* HPHP IDL *)
(*****************************************************************************)

(* 
 * Here is for instance the content of one such IDL file,
 * hphp/src/idl/math.idl.php:
 * 
 *      f('round',   Double,  array('val' => Variant,
 *                       'precision' => array(Int64, '0')));
 * 
 * which defines the interface for the 'round' builtin math function.
 * In the manual at http://us3.php.net/round is is defined a:
 * 
 *     float round  ( float $val  [, int $precision = 0] )
 * 
 * So the only job of this module is to generate from the IDL file 
 * some PHP code like:
 * 
 *    function round($val, $precision = 0) {
 *       // THIS IS AUTOGENERATED BY builtins_php.ml
 *    }
 * 
 * or even better:
 * 
 *    function round(Variant $val, int $precision = 0) double {
 *       // THIS IS AUTOGENERATED BY builtins_php.ml
 *    }
 * 
 * Alternatives: 
 *  - could also define in PHP a f() function that would
 *    do the appropriate things, just like what they do for generating
 *    C++ headers, but then you have to know PHP to do that :) Moreover
 *    here I have defined a type for idl_entry. Types are good!
 *  - could analyze Zend source code
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* see hphp/src/idl/base.php. generated mostly via macro *)
type idl_type = 
  | Boolean

  (* maybe not used *)
  | Byte
  | Int16

  | Int32
  | Int64
  | Double
  | String

  | Int64Vec
  | StringVec
  | VariantVec

  | Int64Map
  | StringMap
  | VariantMap

  | Object
  | Resource

  | Variant

  | Numeric
  | Primitive
  | PlusOperand
  | Sequence

  | Any

  (* Added by me *)
  | NULL
  | Void


type idl_param = {
  p_name: string;
  p_type: idl_type;
  p_isref: bool;
  p_default_val: string option;
}

type idl_entry = 
  | Global of string * idl_type
  | Function of 
      string * idl_type * idl_param list * bool (* has variable arguments *)


let special_comment = 
  "// THIS IS AUTOGENERATED BY builtins_php.ml\n"
let builtins_do_not_give_decl = 
  ["die";"eval";"exit";"__halt_compiler";"echo"; "print"]

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let idl_type__str_conv = [
  Boolean     , "Boolean";
  Byte        , "Byte";
  Int16       , "Int16";
  Int32       , "Int32";
  Int64       , "Int64";
  Double      , "Double";
  String      , "String";
  Int64Vec    , "Int64Vec";
  StringVec   , "StringVec";
  VariantVec  , "VariantVec";
  Int64Map    , "Int64Map";
  StringMap   , "StringMap";
  VariantMap  , "VariantMap";
  Object      , "Object";
  Resource    , "Resource";
  Variant     , "Variant";
  Numeric     , "Numeric";
  Primitive   , "Primitive";
  PlusOperand , "PlusOperand";
  Sequence    , "Sequence";
  Any         , "Any";

  NULL        ,  "NULL";
  NULL        ,  "Null";
]

let (idl_type_of_string, str_of_idl_type) = 
 Common.mk_str_func_of_assoc_conv idl_type__str_conv

let idl_type_of_string (s, info) =
    try idl_type_of_string s
    with Not_found ->
      let pinfo = Ast.parse_info_of_info info in
      pr2 (Common.error_message_info pinfo);
      failwith ("not a idl type: " ^ s)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
exception NotValidIdlPhpEntry

let rec idl_type_of_ast (x : expr) = 
  match untype x with
  | Sc (C (CName (Name (str_typ)))) ->
      idl_type_of_string str_typ, false
  | Binary (e1, (Arith Or, _), e2)  ->

      let typ, is_ref2 = idl_type_of_ast e1 in
      assert(not is_ref2);
      let is_ref =
      (match untype e2 with
      | (Sc (C (CName (Name ("Reference", _))))) ->
          true
      | _ -> raise NotValidIdlPhpEntry
      )
      in
      typ, is_ref

  | _ -> raise NotValidIdlPhpEntry

let idl_arg_to_arg (arg: array_pair) = 
  (* old: "$param" *)
  match arg with
  | ArrayArrowExpr ((Sc (C (Ast.String (str_param, _))), _), _, 
                   targ) ->
      
        (match targ with
        | (ConsArray (_, (_,array_pairs,_)),_) -> 
            (match Ast.uncomma array_pairs with
            |   ArrayExpr (typ)
             :: ArrayExpr (Sc (C (Ast.String (str_expr, _))),_)
             ::[] ->
                  let (typ, isref) = idl_type_of_ast typ in
                  { 
                    p_name = str_param;
                    p_type = typ;
                    p_isref = isref;
                    p_default_val = Some str_expr;
                  }
            | _ -> raise NotValidIdlPhpEntry
            )
        | typ -> 

            let (typ, isref) = idl_type_of_ast typ in
            { 
              p_name = str_param;
              p_type = typ;
              p_isref = isref;
              p_default_val = None;
            }
        )
  | _ -> raise NotValidIdlPhpEntry



let ast_args_to_idl_entry (args: expr list) = 
  match args with
  | [] -> raise NotValidIdlPhpEntry
  | x::xs ->
      (match x with
      | (Sc (C (Ast.String (var_or_func, _))), _) ->
          (match xs with
          | [] -> 
              Function(var_or_func, Void, [], false)

          | [typ] -> 
              let (typ, isref) = idl_type_of_ast typ in
              assert(not isref);
              Function (var_or_func, typ, [], false)
              
          | return_type::spec_args ->
              (match spec_args with
              | (ConsArray (_, (_,array_pairs,_)),_)::maybe_variable_args ->
                 
                  let args = array_pairs +> Ast.uncomma +> List.map idl_arg_to_arg in
                  (* TODO: func extra info *)
                  let variable_arg = 
                    match maybe_variable_args with
                    | [] -> false
                    | [(Sc (C (CName (Name (attr_str,_)))), _)]
                        -> 
                        (match attr_str with
                        | "VariableArguments"
                        | "ReferenceVariableArguments"
                            -> true
                        | "NoEffect" -> false (* ignore for now *)
                        | _ -> raise NotValidIdlPhpEntry
                        )

                    | _ -> raise NotValidIdlPhpEntry
                  in
                  let (typ, isref) = idl_type_of_ast return_type in
                  assert(not isref);
                  Function(var_or_func, typ, args, variable_arg)
              | _ -> raise NotValidIdlPhpEntry
              )
          )
      | _ -> raise NotValidIdlPhpEntry
      )
      



(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let ast_php_to_idl toplevels = 
  match toplevels with
  | [StmtList xs; FinalDef _] ->
      xs +> Common.map_filter (fun stmt ->
        try (
          match stmt with
          | ExprStmt ((IncludeOnce _,_), _) ->
              None
                
          | ExprStmt ((Lv ((FunCallSimple ((Name ("f",info)), args),_)),_), _) ->
              let args' = unparen args +> uncomma +> List.map (function 
                | Arg e -> e
                | ArgRef _ -> raise NotValidIdlPhpEntry
              ) 
              in
              Some (ast_args_to_idl_entry args')

          (* TODO class *)
          | ExprStmt ((Lv ((FunCallSimple ((Name ("c",info)), args),_)),_), _) ->
              pr2 "TODO: Not handling 'c' idl decl";
              None

          (* TODO constant *)
          | ExprStmt ((Lv ((FunCallSimple ((Name ("k",info)), args),_)),_), _) ->
              pr2 "TODO: Not handling 'k' idl decl";
              None



          | ExprStmt ((Lv ((FunCallSimple ((Name ("dyn",info)), args),_)),_), _) ->
              pr2 "TODO: Not handling 'dyn' idl decl";
              None

          | ExprStmt ((Lv ((FunCallSimple ((Name ("p",info)), args),_)),_), _) ->
              pr2 "TODO: Not handling 'p' idl decl";
              None


          | _ -> raise NotValidIdlPhpEntry
        )
        with NotValidIdlPhpEntry ->
          let ii = Lib_parsing_php.ii_of_stmt stmt in
          let info, _max = Lib_parsing_php.min_max_ii_by_pos ii in
          let pinfo = Ast.parse_info_of_info info in
          pr2 ("PB:" ^ (Common.error_message_info pinfo));
          raise NotValidIdlPhpEntry
      )
  | _ -> failwith "does not look like a idl.php file"



let idl_entry_to_php_fake_code entry = 
  match entry with
  | Global (var, _t) ->
      spf "// Global: $%s\n" var

  | Function (func, _typTODO, params, variable_arg) ->
      if List.mem func builtins_do_not_give_decl
      then ""
      else

      let params_str = params +> List.map (fun param ->
        let typ_str = 
          str_of_idl_type param.p_type
        in
        let ref_str = 
          if param.p_isref then "&" else ""
        in
        let default_str = 
          match param.p_default_val with
          | None -> ""
          | Some s -> spf " = %s" s
        in
        (* cf non_empty_parameter_list grammar rule in parser_php.mly *)
        spf "%s %s$%s%s" typ_str ref_str param.p_name default_str
      )
      in
      let str_variable_arg = 
        if variable_arg 
        then "$args = func_num_args(); // fake code to say variable #args\n"
        else "" 
      in

      spf "function %s(%s) {\n %s %s \n}\n"
        func 
        (Common.join ", " params_str) 
        special_comment
        str_variable_arg



(*****************************************************************************)
(* Main entry point *)
(*****************************************************************************)

(* Generating stdlib from idl files *)
let generate_php_stdlib src phpmanual_dir dest = 
  let files = Lib_analyze_php.find_php_files [src] in

  let phpdoc_finder = Phpmanual_xml.build_doc_function_finder phpmanual_dir in

  if not (Common.command2_y_or_no("rm -rf " ^ dest))
  then failwith "ok we stop";
  Common.command2("mkdir -p " ^ dest);

  files +> List.iter (fun file -> 
    pr2 (spf "processing: %s" file);

    if (not (file =~ ".*.idl.php")) 
    then failwith "Files does not end in .idl.php";

    let (ast2,_stat) = Parse_php.parse file in
    let asts = Parse_php.program_of_program2 ast2 in

    let base = Filename.basename file in
    let target = Filename.concat dest ("builtins_" ^ base) in
    Common.with_open_outfile target (fun (pr_no_nl, chan) ->
      (* bugfix: dont forget that :) thx erling *)
      let pr s = pr_no_nl (s ^ "\n") in

      pr "<?php";

      let idl_entries = 
        ast_php_to_idl asts
      in
      idl_entries +> List.iter (fun idl ->
        (match idl with
        | Function (s, _, _, _) ->
            (try
              let str = phpdoc_finder s  in
              let xs = Common.lines str in
              pr "/*";
              xs +> List.iter (fun s -> 
                let s = 
                  Str.global_replace (Str.regexp "[*][/]")
                    " * / " s
                in
                pr (" * " ^ s);
              );
              pr " */";

        
            with exn ->
              pr2 (spf "PB with %s, exn = %s"
                      s (Common.exn_to_s exn));
            )
        | Global _ ->
            (* TODO *)
            ()
        );
        let s = idl_entry_to_php_fake_code idl in
        pr s
      )
    )
  );
  ()

(*****************************************************************************)
(* Actions *)
(*****************************************************************************)

let actions () = [
  (* e.g. 
   * ./pfff_misc -generate_php_stdlib tests/idl/ 
   *    ~/software-src/phpdoc-svn/reference/   data/php_stdlib2
   * to test do:
   * ./pfff_misc -generate_php_stdlib tests/idl/array.idl.php
   *   ~/software-src/phpdoc-svn/reference/array/   data/php_stdlib2
   *)
  "-generate_php_stdlib", " <src_idl> <src_phpmanual> <dest>",
  Common.mk_action_3_arg generate_php_stdlib;
]
@ 
