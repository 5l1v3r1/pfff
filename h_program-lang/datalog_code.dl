% -*- prolog -*-
%*******************************************************************************
% Prelude
%*******************************************************************************

% This file implements a basic context-insensitive pointer analysis.
% Its outputs are the following relations:
%
%   point_to(V, M)           - variable 'V' may point to abstract memory loc 'M'
%   field_point_to(FIELD, M) - qualified field may point to abstract memory loc 'M'
%   call_edge(INVOKE, TARGET) - invocation site 'invoke' calls function 'target'

% Based upon: Java context-insensitive inclusion-based pointer analysis
% by John Whaley

%*******************************************************************************
% Relations
%*******************************************************************************

% Abstract memory locations (also called heap objects), mostly qualified symbols
% (e.g 'main__foo', 'ret_main', '_cst_line2_'):
% - each globals, functions, constants
% - each malloc (context insensitively). will do sensitively later for 
%   malloc wrappers or maybe each malloc with certain type. (e.g. any Proc).
% - each locals (context insensitively first), when their addresses are taken
% - each fields (field-based, see sep08.pdf)
% - array element (array insensitive, aggregation)

% Invocations: line in the file (e.g. '_in_main_line_14_')

%assign(dest:V, source:V) input
%assign_address (v:V, h:H) input
%assign_deref(dest:V, source:V) input
%assign_content(dest:V, source:V) input

%parameter(f:F, z:Z, v:V)
%return(f:F, v:V)
%argument(i:I, z:Z, v:V)
%call_edge(i:I, f:F)
%call_ret(i:I, v:V)
%call_direct(i:I, f:F)
%call_indirect(i:I, v:V)

%assign_array_elt(dest:V, source:V) input
%assign_array_element_address(dest:V, source:V) input
%array_point_to(h:H, h2:H) input/output

%*******************************************************************************
% Rules
%*******************************************************************************

%-------------------------------------------------------------------------------
% Basic
%-------------------------------------------------------------------------------

% p = &q
point_to(P, Q) :-
  assign_address(P, Q).

% p = q
point_to(P, L) :-
        assign(P, Q),
        point_to(Q, L).

% *p = q, given: q -> l, and p -> w => w now points to l
point_to(W, L) :-
  assign_deref(P, Q),
  point_to(Q, L),
  point_to(P, W).

% p = *q
point_to(P, L) :-
        assign_content(P, Q),
        point_to(Q, L).

%-------------------------------------------------------------------------------
% Arrays
%-------------------------------------------------------------------------------

% p = a[...]
point_to(P, AELT) :-
        assign_array_elt(P, A),
        point_to(A, ARRAY),
        array_point_to(ARRAY, AELT).

% a[...] = p
point_to(AELT, L) :-
        assign_array_deref(A, P),
        point_to(A, ARRAY),
        array_point_to(ARRAY, AELT),
        point_to(P, L).

% p = &a[...]
point_to(P, AELT) :-
        assign_array_element_address(P, A),
        point_to(A, ARRAY),
        array_point_to(ARRAY, AELT).
        
%-------------------------------------------------------------------------------
% Calls
%-------------------------------------------------------------------------------

% ret = foo(v1, v2, ...)
assign(PARAM, ARG) :-
        parameter(F, IDX, PARAM),
        call_edge(I, F),
        argument(I, IDX, ARG).
assign(RET, V) :-
        return(F, V),
        call_edge(I, F),
        call_ret(I, RET).

call_edge(I, F) :- 
        call_direct(I, F).
call_edge(I, F) :-
        call_indirect(I, V),
        point_to(V, F).

%*******************************************************************************
% Postlude
%*******************************************************************************
  
point_to(A,B)?
%call_edge(A,B)?
