% -*- prolog -*-
%-------------------------------------------------------------------------------
% Prelude
%-------------------------------------------------------------------------------

% This file implements a basic context-insensitive pointer analysis.
% Its outputs are the following relations:
%
%   point_to(V, M)           - variable 'V' may point to abstract memory loc 'M'
%   field_point_to(FIELD, M) - qualified field may point to abstract memory loc 'M'
%   call_edge(INVOKE, TARGET) - invocation site 'invoke' calls function 'target'

% Based upon: Java context-insensitive inclusion-based pointer analysis
% by John Whaley

%-------------------------------------------------------------------------------
% Relations
%-------------------------------------------------------------------------------

% Abstract memory locations (also called heap objects), mostly qualified symbols
% (e.g 'main__foo', 'ret_main', '_cst_line2_'):
% - each globals, functions, constants
% - each malloc (context insensitively). will do sensitively later for 
%   malloc wrappers or maybe each malloc with certain type. (e.g. any Proc).
% - each locals (context insensitively first), when their addresses are taken
% - each fields (field-based, see sep08.pdf)
% - array element (array insensitive, aggregation)

% Invocations: line in the file (e.g. '_in_main_line_14_')

%assign(dest:V, source:V) input
%assign_address (v:V, h:H) input
%assign_deref(dest:V, source:V) input

%parameter(f:F, z:Z, v:V)
%return(f:F, v:V)
%argument(i:I, z:Z, v:V)
%call_edge(i:I, f:F)
%call_ret(i:I, v:V)
%call_direct(i:I, f:F)
%call_indirect(i:I, v:V)

%-------------------------------------------------------------------------------
% Rules
%-------------------------------------------------------------------------------

% p = &x
point_to(PT, X) :-
  assign_address(PT, X).

% *q = w, given: q -> p, and w -> v => p now points to v
point_to(PT, V) :-
  assign_deref(Q, W),
  point_to(W, V),
  point_to(Q, PT).

% q = p
point_to(P,L) :-
        assign(P, Q),
        point_to(Q, L).


% ret = foo(v1, v2, ...)
assign(PARAM, ARG) :-
        parameter(F, IDX, PARAM),
        call_edge(I, F),
        argument(I, IDX, ARG).
assign(RET, V) :-
        return(F, V),
        call_edge(I, F),
        call_ret(I, RET).

call_edge(I, F) :- 
        call_direct(I, F).
call_edge(I, F) :-
        call_indirect(I, V),
        point_to(V, F).
  
point_to(A,B)?
%call_edge(A,B)?
