(* Yoann Padioleau
 *
 * Copyright (C) 2010 Facebook
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 * 
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)

(* generated by ocamltarzan: ocamltarzan -choice vof ast_cpp.ml *)

open Common

open Ast_cpp
module M = Meta_ast_generic


let _current_precision = ref M.default_precision

let rec vof_info v = Parse_info.vof_info v
and vof_tok v = vof_info v
and vof_wrap _of_a (v1, v2) =
  let v1 = _of_a v1
  and v2 = Ocaml.vof_list vof_info v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_paren _of_a (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_brace _of_a (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_bracket _of_a (v1, v2, v3) =
  let v1 = vof_tok v1
  and v2 = _of_a v2
  and v3 = vof_tok v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_comma_list _of_a = Ocaml.vof_list (vof_wrap _of_a)


let rec vof_name (v1, v2, v3) =
  let v1 = Ocaml.vof_option vof_qtop v1
  and v2 = Ocaml.vof_list vof_qualifier v2
  and v3 = vof_ident v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_ident v = vof_wrap vof_identbis v
and vof_identbis =
  function
  | IdIdent v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("IdIdent", [ v1 ]))
  | IdOperator v1 ->
      let v1 = vof_operator v1 in Ocaml.VSum (("IdOperator", [ v1 ]))
  | IdConverter v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("IdConverter", [ v1 ]))
  | IdDestructor v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("IdDestructor", [ v1 ]))
  | IdTemplateId ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = vof_template_arguments v2
      in Ocaml.VSum (("IdTemplateId", [ v1; v2 ]))
and vof_qualifier v = vof_wrap vof_qualifierbis v
and vof_qualifierbis =
  function
  | QClassname v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("QClassname", [ v1 ]))
  | QTemplateId ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = vof_template_arguments v2
      in Ocaml.VSum (("QTemplateId", [ v1; v2 ]))
and vof_qtop v = vof_wrap vof_qtobis v
and vof_qtobis = function | QTop -> Ocaml.VSum (("QTop", []))
and vof_template_argument v = Ocaml.vof_either vof_fullType vof_expression v
and vof_template_arguments v = vof_comma_list vof_template_argument v
and vof_class_name v = vof_name v
and vof_namespace_name v = vof_name v
and vof_typedef_name v = vof_name v
and vof_enum_name v = vof_name v
and vof_ident_name v = vof_name v
and vof_fullType (v1, v2) =
  let v1 = vof_typeQualifier v1
  and v2 = vof_typeC v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_typeC v = vof_wrap vof_typeCbis v
and vof_typeCbis =
  function
  | BaseType v1 ->
      let v1 = vof_baseType v1 in Ocaml.VSum (("BaseType", [ v1 ]))
  | Pointer v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("Pointer", [ v1 ]))
  | Reference v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("Reference", [ v1 ]))
  | Array ((v1, v2)) ->
      let v1 = Ocaml.vof_option vof_constExpression v1
      and v2 = vof_fullType v2
      in Ocaml.VSum (("Array", [ v1; v2 ]))
  | FunctionType v1 ->
      let v1 = vof_functionType v1 in Ocaml.VSum (("FunctionType", [ v1 ]))
  | Enum ((v1, v2)) ->
      let v1 = Ocaml.vof_option Ocaml.vof_string v1
      and v2 = vof_enumType v2
      in Ocaml.VSum (("Enum", [ v1; v2 ]))
  | StructUnion v1 ->
      let v1 = vof_class_definition v1
      in Ocaml.VSum (("StructUnion", [ v1 ]))
  | EnumName v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("EnumName", [ v1 ]))
  | StructUnionName ((v1, v2)) ->
      let v1 = vof_structUnion v1
      and v2 = Ocaml.vof_string v2
      in Ocaml.VSum (("StructUnionName", [ v1; v2 ]))
  | TypeName ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = Ocaml.vof_option vof_fullType v2
      in Ocaml.VSum (("TypeName", [ v1; v2 ]))
  | TypeTemplate ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = vof_template_arguments v2
      in Ocaml.VSum (("TypeTemplate", [ v1; v2 ]))
  | TypeOfExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("TypeOfExpr", [ v1 ]))
  | TypeOfType v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("TypeOfType", [ v1 ]))
  | TypenameKwd v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("TypenameKwd", [ v1 ]))
  | ParenType v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("ParenType", [ v1 ]))
and vof_baseType =
  function
  | Void -> Ocaml.VSum (("Void", []))
  | IntType v1 -> let v1 = vof_intType v1 in Ocaml.VSum (("IntType", [ v1 ]))
  | FloatType v1 ->
      let v1 = vof_floatType v1 in Ocaml.VSum (("FloatType", [ v1 ]))
and vof_intType =
  function
  | CChar -> Ocaml.VSum (("CChar", []))
  | Si v1 -> let v1 = vof_signed v1 in Ocaml.VSum (("Si", [ v1 ]))
  | CBool -> Ocaml.VSum (("CBool", []))
  | WChar_t -> Ocaml.VSum (("WChar_t", []))
and vof_signed (v1, v2) =
  let v1 = vof_sign v1 and v2 = vof_base v2 in Ocaml.VTuple [ v1; v2 ]
and vof_base =
  function
  | CChar2 -> Ocaml.VSum (("CChar2", []))
  | CShort -> Ocaml.VSum (("CShort", []))
  | CInt -> Ocaml.VSum (("CInt", []))
  | CLong -> Ocaml.VSum (("CLong", []))
  | CLongLong -> Ocaml.VSum (("CLongLong", []))
and vof_sign =
  function
  | Signed -> Ocaml.VSum (("Signed", []))
  | UnSigned -> Ocaml.VSum (("UnSigned", []))
and vof_floatType =
  function
  | CFloat -> Ocaml.VSum (("CFloat", []))
  | CDouble -> Ocaml.VSum (("CDouble", []))
  | CLongDouble -> Ocaml.VSum (("CLongDouble", []))
and vof_enumType v =
  vof_comma_list
    (vof_wrap
       (fun (v1, v2) ->
          let v1 = Ocaml.vof_string v1
          and v2 = Ocaml.vof_option vof_constExpression v2
          in Ocaml.VTuple [ v1; v2 ]))
    v
and vof_functionType (v1, v2) =
  let v1 = vof_fullType v1
  and v2 =
    match v2 with
    | (v1, v2) ->
        let v1 = vof_comma_list vof_parameterType v1
        and v2 = vof_wrap Ocaml.vof_bool v2
        in Ocaml.VTuple [ v1; v2 ]
  in Ocaml.VTuple [ v1; v2 ]
and vof_parameterType v =
  vof_wrap
    (fun (v1, v2, v3) ->
       let v1 = Ocaml.vof_bool v1
       and v2 = Ocaml.vof_option Ocaml.vof_string v2
       and v3 = vof_fullType v3
       in Ocaml.VTuple [ v1; v2; v3 ])
    v
and vof_typeQualifier v = vof_wrap vof_typeQualifierbis v
and vof_typeQualifierbis { const = v_const; volatile = v_volatile } =
  let bnds = [] in
  let arg = Ocaml.vof_bool v_volatile in
  let bnd = ("volatile", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_bool v_const in
  let bnd = ("const", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_expression v =
  vof_wrap
    (fun (v1, v2) ->
       let v1 = vof_expressionbis v1
       and v2 = Ocaml.vof_ref (Ocaml.vof_option vof_fullType) v2
       in Ocaml.VTuple [ v1; v2 ])
    v
and vof_expressionbis =
  function
  | Ident v1 -> let v1 = vof_name v1 in Ocaml.VSum (("Ident", [ v1 ]))
  | Constant v1 ->
      let v1 = vof_constant v1 in Ocaml.VSum (("Constant", [ v1 ]))
  | This -> Ocaml.VSum (("This", []))
  | FunCall ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_comma_list vof_argument v2
      in Ocaml.VSum (("FunCall", [ v1; v2 ]))
  | CondExpr ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = Ocaml.vof_option vof_expression v2
      and v3 = vof_expression v3
      in Ocaml.VSum (("CondExpr", [ v1; v2; v3 ]))
  | Sequence ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("Sequence", [ v1; v2 ]))
  | Assignment ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_assignOp v2
      and v3 = vof_expression v3
      in Ocaml.VSum (("Assignment", [ v1; v2; v3 ]))
  | Postfix ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_fixOp v2
      in Ocaml.VSum (("Postfix", [ v1; v2 ]))
  | Infix ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_fixOp v2
      in Ocaml.VSum (("Infix", [ v1; v2 ]))
  | Unary ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_unaryOp v2
      in Ocaml.VSum (("Unary", [ v1; v2 ]))
  | Binary ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_binaryOp v2
      and v3 = vof_expression v3
      in Ocaml.VSum (("Binary", [ v1; v2; v3 ]))
  | ArrayAccess ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("ArrayAccess", [ v1; v2 ]))
  | RecordAccess ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_name v2
      in Ocaml.VSum (("RecordAccess", [ v1; v2 ]))
  | RecordPtAccess ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_name v2
      in Ocaml.VSum (("RecordPtAccess", [ v1; v2 ]))
  | RecordStarAccess ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("RecordStarAccess", [ v1; v2 ]))
  | RecordPtStarAccess ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("RecordPtStarAccess", [ v1; v2 ]))
  | SizeOfExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("SizeOfExpr", [ v1 ]))
  | SizeOfType v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("SizeOfType", [ v1 ]))
  | Cast ((v1, v2)) ->
      let v1 = vof_fullType v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("Cast", [ v1; v2 ]))
  | CplusplusCast ((v1, v2, v3)) ->
      let v1 = vof_cast_operator v1
      and v2 = vof_fullType v2
      and v3 = vof_expression v3
      in Ocaml.VSum (("CplusplusCast", [ v1; v2; v3 ]))
  | StatementExpr v1 ->
      let v1 = vof_wrap vof_compound v1
      in Ocaml.VSum (("StatementExpr", [ v1 ]))
  | GccConstructor ((v1, v2)) ->
      let v1 = vof_fullType v1
      and v2 = vof_comma_list vof_initialiser v2
      in Ocaml.VSum (("GccConstructor", [ v1; v2 ]))
  | ConstructedObject ((v1, v2)) ->
      let v1 = vof_fullType v1
      and v2 = vof_comma_list vof_argument v2
      in Ocaml.VSum (("ConstructedObject", [ v1; v2 ]))
  | TypeIdOfExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("TypeIdOfExpr", [ v1 ]))
  | TypeIdOfType v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("TypeIdOfType", [ v1 ]))
  | New -> Ocaml.VSum (("New", []))
  | Delete ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = Ocaml.vof_option vof_qtop v2
      in Ocaml.VSum (("Delete", [ v1; v2 ]))
  | DeleteArray ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = Ocaml.vof_option vof_qtop v2
      in Ocaml.VSum (("DeleteArray", [ v1; v2 ]))
  | Throw v1 ->
      let v1 = Ocaml.vof_option vof_expression v1
      in Ocaml.VSum (("Throw", [ v1 ]))
  | ParenExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("ParenExpr", [ v1 ]))
and vof_argument v = Ocaml.vof_either vof_expression vof_wierd_argument v
and vof_wierd_argument =
  function
  | ArgType v1 ->
      let v1 = vof_parameterType v1 in Ocaml.VSum (("ArgType", [ v1 ]))
  | ArgAction v1 ->
      let v1 = vof_action_macro v1 in Ocaml.VSum (("ArgAction", [ v1 ]))
and vof_action_macro =
  function
  | ActMisc v1 ->
      let v1 = Ocaml.vof_list vof_tok v1 in Ocaml.VSum (("ActMisc", [ v1 ]))
and vof_constant =
  function
  | String v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = vof_isWchar v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("String", [ v1 ]))
  | MultiString -> Ocaml.VSum (("MultiString", []))
  | Char v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = vof_isWchar v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("Char", [ v1 ]))
  | Int v1 -> let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("Int", [ v1 ]))
  | Float v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = vof_floatType v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("Float", [ v1 ]))
  | Bool v1 -> let v1 = Ocaml.vof_bool v1 in Ocaml.VSum (("Bool", [ v1 ]))
and vof_isWchar =
  function
  | IsWchar -> Ocaml.VSum (("IsWchar", []))
  | IsChar -> Ocaml.VSum (("IsChar", []))
and vof_unaryOp =
  function
  | GetRef -> Ocaml.VSum (("GetRef", []))
  | DeRef -> Ocaml.VSum (("DeRef", []))
  | UnPlus -> Ocaml.VSum (("UnPlus", []))
  | UnMinus -> Ocaml.VSum (("UnMinus", []))
  | Tilde -> Ocaml.VSum (("Tilde", []))
  | Not -> Ocaml.VSum (("Not", []))
  | GetRefLabel -> Ocaml.VSum (("GetRefLabel", []))
and vof_assignOp =
  function
  | SimpleAssign -> Ocaml.VSum (("SimpleAssign", []))
  | OpAssign v1 ->
      let v1 = vof_arithOp v1 in Ocaml.VSum (("OpAssign", [ v1 ]))
and vof_fixOp =
  function
  | Dec -> Ocaml.VSum (("Dec", []))
  | Inc -> Ocaml.VSum (("Inc", []))
and vof_binaryOp =
  function
  | Arith v1 -> let v1 = vof_arithOp v1 in Ocaml.VSum (("Arith", [ v1 ]))
  | Logical v1 ->
      let v1 = vof_logicalOp v1 in Ocaml.VSum (("Logical", [ v1 ]))
and vof_arithOp =
  function
  | Plus -> Ocaml.VSum (("Plus", []))
  | Minus -> Ocaml.VSum (("Minus", []))
  | Mul -> Ocaml.VSum (("Mul", []))
  | Div -> Ocaml.VSum (("Div", []))
  | Mod -> Ocaml.VSum (("Mod", []))
  | DecLeft -> Ocaml.VSum (("DecLeft", []))
  | DecRight -> Ocaml.VSum (("DecRight", []))
  | And -> Ocaml.VSum (("And", []))
  | Or -> Ocaml.VSum (("Or", []))
  | Xor -> Ocaml.VSum (("Xor", []))
and vof_logicalOp =
  function
  | Inf -> Ocaml.VSum (("Inf", []))
  | Sup -> Ocaml.VSum (("Sup", []))
  | InfEq -> Ocaml.VSum (("InfEq", []))
  | SupEq -> Ocaml.VSum (("SupEq", []))
  | Eq -> Ocaml.VSum (("Eq", []))
  | NotEq -> Ocaml.VSum (("NotEq", []))
  | AndLog -> Ocaml.VSum (("AndLog", []))
  | OrLog -> Ocaml.VSum (("OrLog", []))
and vof_ptrOp =
  function
  | PtrStarOp -> Ocaml.VSum (("PtrStarOp", []))
  | PtrOp -> Ocaml.VSum (("PtrOp", []))
and vof_allocOp =
  function
  | NewOp -> Ocaml.VSum (("NewOp", []))
  | DeleteOp -> Ocaml.VSum (("DeleteOp", []))
  | NewArrayOp -> Ocaml.VSum (("NewArrayOp", []))
  | DeleteArrayOp -> Ocaml.VSum (("DeleteArrayOp", []))
and vof_accessop =
  function
  | ParenOp -> Ocaml.VSum (("ParenOp", []))
  | ArrayOp -> Ocaml.VSum (("ArrayOp", []))
and vof_operator =
  function
  | BinaryOp v1 ->
      let v1 = vof_binaryOp v1 in Ocaml.VSum (("BinaryOp", [ v1 ]))
  | AssignOp v1 ->
      let v1 = vof_assignOp v1 in Ocaml.VSum (("AssignOp", [ v1 ]))
  | FixOp v1 -> let v1 = vof_fixOp v1 in Ocaml.VSum (("FixOp", [ v1 ]))
  | PtrOpOp v1 -> let v1 = vof_ptrOp v1 in Ocaml.VSum (("PtrOpOp", [ v1 ]))
  | AccessOp v1 ->
      let v1 = vof_accessop v1 in Ocaml.VSum (("AccessOp", [ v1 ]))
  | AllocOp v1 -> let v1 = vof_allocOp v1 in Ocaml.VSum (("AllocOp", [ v1 ]))
  | UnaryTildeOp -> Ocaml.VSum (("UnaryTildeOp", []))
  | UnaryNotOp -> Ocaml.VSum (("UnaryNotOp", []))
  | CommaOp -> Ocaml.VSum (("CommaOp", []))
and vof_cast_operator =
  function
  | Static_cast -> Ocaml.VSum (("Static_cast", []))
  | Dynamic_cast -> Ocaml.VSum (("Dynamic_cast", []))
  | Const_cast -> Ocaml.VSum (("Const_cast", []))
  | Reinterpret_cast -> Ocaml.VSum (("Reinterpret_cast", []))
and vof_constExpression v = vof_expression v
and vof_statement v = vof_wrap vof_statementbis v
and vof_statementbis =
  function
  | Compound v1 ->
      let v1 = vof_compound v1 in Ocaml.VSum (("Compound", [ v1 ]))
  | ExprStatement v1 ->
      let v1 = vof_exprStatement v1 in Ocaml.VSum (("ExprStatement", [ v1 ]))
  | Labeled v1 -> let v1 = vof_labeled v1 in Ocaml.VSum (("Labeled", [ v1 ]))
  | Selection v1 ->
      let v1 = vof_selection v1 in Ocaml.VSum (("Selection", [ v1 ]))
  | Iteration v1 ->
      let v1 = vof_iteration v1 in Ocaml.VSum (("Iteration", [ v1 ]))
  | Jump v1 -> let v1 = vof_jump v1 in Ocaml.VSum (("Jump", [ v1 ]))
  | DeclStmt v1 ->
      let v1 = vof_block_declaration v1 in Ocaml.VSum (("DeclStmt", [ v1 ]))
  | NestedFunc v1 ->
      let v1 = vof_definition v1 in Ocaml.VSum (("NestedFunc", [ v1 ]))
  | MacroStmt -> Ocaml.VSum (("MacroStmt", []))
  | Try ((v1, v2)) ->
      let v1 = vof_wrap vof_compound v1
      and v2 = Ocaml.vof_list vof_handler v2
      in Ocaml.VSum (("Try", [ v1; v2 ]))
and vof_compound v = Ocaml.vof_list vof_statement_sequencable v
and vof_statement_sequencable =
  function
  | StmtElem v1 ->
      let v1 = vof_statement v1 in Ocaml.VSum (("StmtElem", [ v1 ]))
  | CppDirectiveStmt v1 ->
      let v1 = vof_cpp_directive v1
      in Ocaml.VSum (("CppDirectiveStmt", [ v1 ]))
  | IfdefStmt v1 ->
      let v1 = vof_ifdef_directive v1 in Ocaml.VSum (("IfdefStmt", [ v1 ]))
and vof_exprStatement v = Ocaml.vof_option vof_expression v
and vof_labeled =
  function
  | Label ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = vof_statement v2
      in Ocaml.VSum (("Label", [ v1; v2 ]))
  | Case ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_statement v2
      in Ocaml.VSum (("Case", [ v1; v2 ]))
  | CaseRange ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      and v3 = vof_statement v3
      in Ocaml.VSum (("CaseRange", [ v1; v2; v3 ]))
  | Default v1 ->
      let v1 = vof_statement v1 in Ocaml.VSum (("Default", [ v1 ]))
and vof_selection =
  function
  | If ((v1, v2, v3)) ->
      let v1 = vof_expression v1
      and v2 = vof_statement v2
      and v3 = vof_statement v3
      in Ocaml.VSum (("If", [ v1; v2; v3 ]))
  | Switch ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_statement v2
      in Ocaml.VSum (("Switch", [ v1; v2 ]))
and vof_iteration =
  function
  | While ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_statement v2
      in Ocaml.VSum (("While", [ v1; v2 ]))
  | DoWhile ((v1, v2)) ->
      let v1 = vof_statement v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("DoWhile", [ v1; v2 ]))
  | For ((v1, v2, v3, v4)) ->
      let v1 = vof_wrap vof_exprStatement v1
      and v2 = vof_wrap vof_exprStatement v2
      and v3 = vof_wrap vof_exprStatement v3
      and v4 = vof_statement v4
      in Ocaml.VSum (("For", [ v1; v2; v3; v4 ]))
  | MacroIteration ((v1, v2, v3)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = vof_comma_list vof_argument v2
      and v3 = vof_statement v3
      in Ocaml.VSum (("MacroIteration", [ v1; v2; v3 ]))
and vof_jump =
  function
  | Goto v1 -> let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("Goto", [ v1 ]))
  | Continue -> Ocaml.VSum (("Continue", []))
  | Break -> Ocaml.VSum (("Break", []))
  | Return -> Ocaml.VSum (("Return", []))
  | ReturnExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("ReturnExpr", [ v1 ]))
  | GotoComputed v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("GotoComputed", [ v1 ]))
and vof_handler (v1, v2) =
  let v1 = vof_wrap vof_exception_declaration v1
  and v2 = vof_wrap vof_compound v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_exception_declaration =
  function
  | ExnDeclEllipsis v1 ->
      let v1 = vof_info v1 in Ocaml.VSum (("ExnDeclEllipsis", [ v1 ]))
  | ExnDecl v1 ->
      let v1 = vof_parameterType v1 in Ocaml.VSum (("ExnDecl", [ v1 ]))
and vof_block_declaration v = vof_wrap vof_block_declarationbis v
and vof_block_declarationbis =
  function
  | SimpleDecl v1 ->
      let v1 = vof_var_declaration v1 in Ocaml.VSum (("SimpleDecl", [ v1 ]))
  | UsingDecl v1 ->
      let v1 = vof_name v1 in Ocaml.VSum (("UsingDecl", [ v1 ]))
  | UsingDirective v1 ->
      let v1 = vof_namespace_name v1
      in Ocaml.VSum (("UsingDirective", [ v1 ]))
  | NameSpaceAlias ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = vof_namespace_name v2
      in Ocaml.VSum (("NameSpaceAlias", [ v1; v2 ]))
  | Asm v1 -> let v1 = vof_asmbody v1 in Ocaml.VSum (("Asm", [ v1 ]))
and vof_asmbody (v1, v2) =
  let v1 = Ocaml.vof_list vof_tok v1
  and v2 = Ocaml.vof_list (vof_wrap vof_colon) v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_colon =
  function
  | Colon v1 ->
      let v1 = vof_comma_list vof_colon_option v1
      in Ocaml.VSum (("Colon", [ v1 ]))
and vof_colon_option v = vof_wrap vof_colon_optionbis v
and vof_colon_optionbis =
  function
  | ColonMisc -> Ocaml.VSum (("ColonMisc", []))
  | ColonExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("ColonExpr", [ v1 ]))
and vof_var_declaration =
  function
  | DeclList v1 ->
      let v1 = vof_wrap (vof_comma_list vof_onedecl) v1
      in Ocaml.VSum (("DeclList", [ v1 ]))
  | MacroDecl v1 ->
      let v1 =
        vof_wrap
          (fun (v1, v2) ->
             let v1 = Ocaml.vof_string v1
             and v2 = vof_comma_list vof_argument v2
             in Ocaml.VTuple [ v1; v2 ])
          v1
      in Ocaml.VSum (("MacroDecl", [ v1 ]))
and vof_onedecl (v1, v2, v3) =
  let v1 =
    Ocaml.vof_option
      (vof_wrap
         (fun (v1, v2) ->
            let v1 = vof_name v1
            and v2 = Ocaml.vof_option vof_initialiser v2
            in Ocaml.VTuple [ v1; v2 ]))
      v1
  and v2 = vof_fullType v2
  and v3 = vof_storage v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_storage (v1, v2) =
  let v1 = vof_storagebis v1
  and v2 = Ocaml.vof_bool v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_storagebis =
  function
  | NoSto -> Ocaml.VSum (("NoSto", []))
  | StoTypedef -> Ocaml.VSum (("StoTypedef", []))
  | Sto v1 -> let v1 = vof_storageClass v1 in Ocaml.VSum (("Sto", [ v1 ]))
and vof_storageClass =
  function
  | Auto -> Ocaml.VSum (("Auto", []))
  | Static -> Ocaml.VSum (("Static", []))
  | Register -> Ocaml.VSum (("Register", []))
  | Extern -> Ocaml.VSum (("Extern", []))
and vof_func_specifier =
  function
  | Inline -> Ocaml.VSum (("Inline", []))
  | Virtual -> Ocaml.VSum (("Virtual", []))
and vof_initialiser v = vof_wrap vof_initialiserbis v
and vof_initialiserbis =
  function
  | InitExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("InitExpr", [ v1 ]))
  | InitList v1 ->
      let v1 = vof_comma_list vof_initialiser v1
      in Ocaml.VSum (("InitList", [ v1 ]))
  | InitDesignators ((v1, v2)) ->
      let v1 = Ocaml.vof_list vof_designator v1
      and v2 = vof_initialiser v2
      in Ocaml.VSum (("InitDesignators", [ v1; v2 ]))
  | InitFieldOld ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = vof_initialiser v2
      in Ocaml.VSum (("InitFieldOld", [ v1; v2 ]))
  | InitIndexOld ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_initialiser v2
      in Ocaml.VSum (("InitIndexOld", [ v1; v2 ]))
and vof_designator v = vof_wrap vof_designatorbis v
and vof_designatorbis =
  function
  | DesignatorField v1 ->
      let v1 = Ocaml.vof_string v1
      in Ocaml.VSum (("DesignatorField", [ v1 ]))
  | DesignatorIndex v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("DesignatorIndex", [ v1 ]))
  | DesignatorRange ((v1, v2)) ->
      let v1 = vof_expression v1
      and v2 = vof_expression v2
      in Ocaml.VSum (("DesignatorRange", [ v1; v2 ]))
and vof_definition v =
  vof_wrap
    (fun (v1, v2, v3, v4) ->
       let v1 = Ocaml.vof_string v1
       and v2 = vof_functionType v2
       and v3 = vof_storage v3
       and v4 = vof_compound v4
       in Ocaml.VTuple [ v1; v2; v3; v4 ])
    v
and vof_class_definition v =
  vof_wrap
    (fun (v1, v2, v3, v4) ->
       let v1 = vof_structUnion v1
       and v2 = Ocaml.vof_option vof_ident_name v2
       and v3 = Ocaml.vof_option (vof_comma_list vof_base_clause) v3
       and v4 = Ocaml.vof_list vof_class_member_sequencable v4
       in Ocaml.VTuple [ v1; v2; v3; v4 ])
    v
and vof_structUnion =
  function
  | Struct -> Ocaml.VSum (("Struct", []))
  | Union -> Ocaml.VSum (("Union", []))
  | Class -> Ocaml.VSum (("Class", []))
and vof_access_spec =
  function
  | Public -> Ocaml.VSum (("Public", []))
  | Private -> Ocaml.VSum (("Private", []))
  | Protected -> Ocaml.VSum (("Protected", []))
and vof_class_member v = vof_wrap vof_class_memberbis v
and vof_class_memberbis =
  function
  | Access v1 ->
      let v1 = vof_access_spec v1 in Ocaml.VSum (("Access", [ v1 ]))
  | DeclarationField v1 ->
      let v1 = vof_field_declaration v1
      in Ocaml.VSum (("DeclarationField", [ v1 ]))
  | Method v1 ->
      let v1 = vof_definition v1 in Ocaml.VSum (("Method", [ v1 ]))
  | Constructor ((v1, v2)) ->
      let v1 = vof_definition v1
      and v2 = Ocaml.vof_bool v2
      in Ocaml.VSum (("Constructor", [ v1; v2 ]))
  | Destructor v1 ->
      let v1 = vof_definition v1 in Ocaml.VSum (("Destructor", [ v1 ]))
  | ConstructorDecl ((v1, v2)) ->
      let v1 = vof_comma_list vof_parameterType v1
      and v2 = Ocaml.vof_bool v2
      in Ocaml.VSum (("ConstructorDecl", [ v1; v2 ]))
  | DestructorDecl ((v1, v2)) ->
      let v1 = vof_name v1
      and v2 = Ocaml.vof_bool v2
      in Ocaml.VSum (("DestructorDecl", [ v1; v2 ]))
  | QualifiedIdInClass v1 ->
      let v1 = vof_name v1 in Ocaml.VSum (("QualifiedIdInClass", [ v1 ]))
  | TemplateDeclInClass v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = vof_template_parameters v1
             and v2 = vof_declaration v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("TemplateDeclInClass", [ v1 ]))
  | UsingDeclInClass v1 ->
      let v1 = vof_name v1 in Ocaml.VSum (("UsingDeclInClass", [ v1 ]))
  | EmptyField -> Ocaml.VSum (("EmptyField", []))
and vof_field_declaration =
  function
  | FieldDeclList v1 ->
      let v1 = vof_wrap (vof_comma_list vof_fieldkind) v1
      in Ocaml.VSum (("FieldDeclList", [ v1 ]))
and vof_fieldkind v = vof_wrap vof_fieldkindbis v
and vof_fieldkindbis =
  function
  | FieldDecl v1 ->
      let v1 = vof_onedecl v1 in Ocaml.VSum (("FieldDecl", [ v1 ]))
  | MethodDecl ((v1, v2)) ->
      let v1 = vof_onedecl v1
      and v2 = Ocaml.vof_bool v2
      in Ocaml.VSum (("MethodDecl", [ v1; v2 ]))
  | BitField ((v1, v2, v3)) ->
      let v1 = Ocaml.vof_option Ocaml.vof_string v1
      and v2 = vof_fullType v2
      and v3 = vof_constExpression v3
      in Ocaml.VSum (("BitField", [ v1; v2; v3 ]))
and vof_class_member_sequencable =
  function
  | ClassElem v1 ->
      let v1 = vof_class_member v1 in Ocaml.VSum (("ClassElem", [ v1 ]))
  | CppDirectiveStruct v1 ->
      let v1 = vof_cpp_directive v1
      in Ocaml.VSum (("CppDirectiveStruct", [ v1 ]))
  | IfdefStruct v1 ->
      let v1 = vof_ifdef_directive v1 in Ocaml.VSum (("IfdefStruct", [ v1 ]))
and vof_base_clause v = vof_wrap vof_base_clausebis v
and vof_base_clausebis (v1, v2, v3) =
  let v1 = vof_class_name v1
  and v2 = Ocaml.vof_bool v2
  and v3 = Ocaml.vof_option vof_access_spec v3
  in Ocaml.VTuple [ v1; v2; v3 ]
and vof_declaration v = vof_wrap vof_declarationbis v
and vof_declarationbis =
  function
  | Declaration v1 ->
      let v1 = vof_block_declaration v1
      in Ocaml.VSum (("Declaration", [ v1 ]))
  | Definition v1 ->
      let v1 = vof_definition v1 in Ocaml.VSum (("Definition", [ v1 ]))
  | ConstructorTop ((v1, v2)) ->
      let v1 = vof_definition v1
      and v2 = Ocaml.vof_bool v2
      in Ocaml.VSum (("ConstructorTop", [ v1; v2 ]))
  | DestructorTop v1 ->
      let v1 = vof_definition v1 in Ocaml.VSum (("DestructorTop", [ v1 ]))
  | TemplateDecl v1 ->
      let v1 =
        (match v1 with
         | (v1, v2) ->
             let v1 = vof_template_parameters v1
             and v2 = vof_declaration v2
             in Ocaml.VTuple [ v1; v2 ])
      in Ocaml.VSum (("TemplateDecl", [ v1 ]))
  | TemplateSpecialization v1 ->
      let v1 = vof_declaration v1
      in Ocaml.VSum (("TemplateSpecialization", [ v1 ]))
  | ExternC v1 ->
      let v1 = vof_declaration v1 in Ocaml.VSum (("ExternC", [ v1 ]))
  | ExternCList v1 ->
      let v1 = Ocaml.vof_list vof_declaration_sequencable v1
      in Ocaml.VSum (("ExternCList", [ v1 ]))
  | NameSpace ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = Ocaml.vof_list vof_declaration_sequencable v2
      in Ocaml.VSum (("NameSpace", [ v1; v2 ]))
  | NameSpaceExtend ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = Ocaml.vof_list vof_declaration_sequencable v2
      in Ocaml.VSum (("NameSpaceExtend", [ v1; v2 ]))
  | NameSpaceAnon v1 ->
      let v1 = Ocaml.vof_list vof_declaration_sequencable v1
      in Ocaml.VSum (("NameSpaceAnon", [ v1 ]))
and vof_template_parameters v = vof_comma_list vof_template_parameter v
and vof_template_parameter v = vof_parameterType v
and vof_declaration_sequencable =
  function
  | DeclElem v1 ->
      let v1 = vof_declaration v1 in Ocaml.VSum (("DeclElem", [ v1 ]))
  | CppDirectiveDecl v1 ->
      let v1 = vof_cpp_directive v1
      in Ocaml.VSum (("CppDirectiveDecl", [ v1 ]))
  | IfdefDecl v1 ->
      let v1 = vof_ifdef_directive v1 in Ocaml.VSum (("IfdefDecl", [ v1 ]))
and vof_cpp_directive =
  function
  | Include v1 -> let v1 = vof_includ v1 in Ocaml.VSum (("Include", [ v1 ]))
  | Define v1 -> let v1 = vof_define v1 in Ocaml.VSum (("Define", [ v1 ]))
  | Undef ((v1, v2)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = Ocaml.vof_list vof_tok v2
      in Ocaml.VSum (("Undef", [ v1; v2 ]))
  | PragmaAndCo v1 ->
      let v1 = Ocaml.vof_list vof_tok v1
      in Ocaml.VSum (("PragmaAndCo", [ v1 ]))
and vof_ifdef_directive =
  function
  | IfdefDirective v1 ->
      let v1 = Ocaml.vof_list vof_tok v1
      in Ocaml.VSum (("IfdefDirective", [ v1 ]))
and vof_define (v1, v2) =
  let v1 = vof_wrap Ocaml.vof_string v1
  and v2 = vof_define_body v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_define_body (v1, v2) =
  let v1 = vof_define_kind v1
  and v2 = vof_define_val v2
  in Ocaml.VTuple [ v1; v2 ]
and vof_define_kind =
  function
  | DefineVar -> Ocaml.VSum (("DefineVar", []))
  | DefineFunc v1 ->
      let v1 = vof_wrap (vof_comma_list (vof_wrap Ocaml.vof_string)) v1
      in Ocaml.VSum (("DefineFunc", [ v1 ]))
and vof_define_val =
  function
  | DefineExpr v1 ->
      let v1 = vof_expression v1 in Ocaml.VSum (("DefineExpr", [ v1 ]))
  | DefineStmt v1 ->
      let v1 = vof_statement v1 in Ocaml.VSum (("DefineStmt", [ v1 ]))
  | DefineType v1 ->
      let v1 = vof_fullType v1 in Ocaml.VSum (("DefineType", [ v1 ]))
  | DefineDoWhileZero v1 ->
      let v1 = vof_wrap vof_statement v1
      in Ocaml.VSum (("DefineDoWhileZero", [ v1 ]))
  | DefineFunction v1 ->
      let v1 = vof_definition v1 in Ocaml.VSum (("DefineFunction", [ v1 ]))
  | DefineInit v1 ->
      let v1 = vof_initialiser v1 in Ocaml.VSum (("DefineInit", [ v1 ]))
  | DefineText v1 ->
      let v1 = vof_wrap Ocaml.vof_string v1
      in Ocaml.VSum (("DefineText", [ v1 ]))
  | DefineEmpty -> Ocaml.VSum (("DefineEmpty", []))
  | DefineTodo -> Ocaml.VSum (("DefineTodo", []))
and vof_includ (v1, v2) =
  let v1 = vof_wrap vof_inc_file v1
  and v2 =
    match v2 with
    | (v1, v2) ->
        let v1 = Ocaml.vof_unit v1
        and v2 = Ocaml.vof_bool v2
        in Ocaml.VTuple [ v1; v2 ]
  in Ocaml.VTuple [ v1; v2 ]
and vof_inc_file =
  function
  | Local v1 ->
      let v1 = Ocaml.vof_list vof_inc_elem v1
      in Ocaml.VSum (("Local", [ v1 ]))
  | NonLocal v1 ->
      let v1 = Ocaml.vof_list vof_inc_elem v1
      in Ocaml.VSum (("NonLocal", [ v1 ]))
  | Wierd v1 ->
      let v1 = Ocaml.vof_string v1 in Ocaml.VSum (("Wierd", [ v1 ]))
and vof_inc_elem v = Ocaml.vof_string v
and vof_toplevel =
  function
  | TopDecl v1 ->
      let v1 = vof_declaration v1 in Ocaml.VSum (("TopDecl", [ v1 ]))
  | CppTop v1 ->
      let v1 = vof_cpp_directive v1 in Ocaml.VSum (("CppTop", [ v1 ]))
  | IfdefTop v1 ->
      let v1 = vof_ifdef_directive v1 in Ocaml.VSum (("IfdefTop", [ v1 ]))
  | MacroTop ((v1, v2, v3)) ->
      let v1 = Ocaml.vof_string v1
      and v2 = vof_comma_list vof_argument v2
      and v3 = Ocaml.vof_list vof_tok v3
      in Ocaml.VSum (("MacroTop", [ v1; v2; v3 ]))
  | EmptyDef v1 ->
      let v1 = Ocaml.vof_list vof_tok v1 in Ocaml.VSum (("EmptyDef", [ v1 ]))
  | NotParsedCorrectly v1 ->
      let v1 = Ocaml.vof_list vof_tok v1
      in Ocaml.VSum (("NotParsedCorrectly", [ v1 ]))
  | FinalDef v1 -> let v1 = vof_info v1 in Ocaml.VSum (("FinalDef", [ v1 ]))
and vof_program_orig v = Ocaml.vof_list vof_toplevel v
  
(* end auto generation *)

let vof_program precision x = 
  Common.save_excursion _current_precision precision (fun () ->
    vof_program_orig x
  )

