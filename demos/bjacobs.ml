open Common

open Ast_php

module Ast = Ast_php
module V = Visitor_php

module J = Json_type

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(* 
 * Goal: output a json file containing dependency information about
 * a PHP file passed as a command line argument.
 * 
 * timing:
 *  3h00: start
 *  3h15: have depends with json output
 *  3h30: got includes, require_module, and 'new' handling
 * 
 * update: handling define() constants (this is really similar to
 * checkModule ...)
 * update: handling some flib logic
 * update: better handling of inclusion (PHP_ROOT, XHPROF_LIB_ROOT, etc)
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* 
 * Here is what must be generated for demos/foo2.php:
 * 
 * {"includes":
 * [{"file":"lib/foo.php", "line":3, "column":1},
 * {"file":"flib/foo/bar/__init__.php", "line":4, "column":1}],
 * "provides":
 * [{"class":"Foo", "line":6, "column":1},
 * {"func":"bar_func", "line":17, "column":1}],
 * "depends":
 * [{"func":"require_module", "line":4, "column":1},
 * {"class":"Bar", "line":6, "column":18},
 * {"func":"foo_func", "line":8, "column":4},
 * {"class":"Bar", "line":12, "column":15}]}
 *)

type pos = {
  line: int;
  column: int;
}

type entity = {
  e_kind: e_kind;
  e_pos: pos;
}
 and e_kind = 
   | Class of string
   | Function of string
   | Constant of string

type thrift_class = {
  t_class: string;
  t_file: Common.filename;
  t_pos: pos;
}

type deps = {
  includes: (Common.filename * pos) list;
  provides: entity list;
  depends:  entity list;
  thrift_autoload: thrift_class list;
}

(* TODO: should use data/php_stdlib now *)
let builtin_constants = [
  "true";
  "false";
  "null";
]

exception UnrecognizedInclude of string 
exception UnrecognizedRequire of string 

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
let pos_of_info info = 
  { line = Ast.line_of_info info;
    column = Ast.col_of_info info;
  }

(*****************************************************************************)
(* Json output *)
(*****************************************************************************)

(* could be autogenerated by ocamltarzan *)

let (json_of_pos: pos -> (string * Json_type.json_type) list) = fun e ->
  [("line", J.Int e.line);
   ("column", J.Int e.column);
  ]

let (json_of_entity: entity -> Json_type.json_type) = fun e ->
  J.Object (
    (match e.e_kind with
    | Class s ->   ("class", J.String s)
    | Function s -> ("func", J.String s)
    | Constant s -> ("constant", J.String s)
    )::json_of_pos e.e_pos
  )


let (json_of_thrift_class: thrift_class -> Json_type.json_type) = fun x ->
  J.Object ([
    "class", J.String x.t_class;
    "file", J.String x.t_file;
    ] ++ json_of_pos x.t_pos)
  

let (json_of_deps: deps -> Json_type.json_type) = fun deps ->
  J.Object [
    ("includes", 
    J.Array (deps.includes +> List.map (fun (file, pos) ->
      J.Object (("file", J.String file)::json_of_pos pos))));
    ("provides", 
    J.Array (deps.provides +> List.map json_of_entity));
    ("depends", 
    J.Array (deps.depends +> List.map json_of_entity));
    ("thrift_autoload", 
    J.Array (deps.thrift_autoload +> List.map json_of_thrift_class));
  ]

(*****************************************************************************)
(* Path analysis for the require, include, and require_external_source *)
(*****************************************************************************)

(* Heuristics for handling include/require, e.g. 
 * include _SERVER['PHP_ROOT'].'/lib/third-party/foo.php;
 * 
 * Take the string expression as a parameter and return a path
 * relative to www/
 * 
 * Assumes people put a '/' as the start of the string in the second
 * argument of the concatenation operator (e.g. '/lib/...')
 * 
 * TODO: should now use include_require_php.ml
 *)

let (path_analysis: Ast_php.expr -> Ast_php.info -> Common.filename) = 
 fun e tok (* token of 'include' or 'require' *) ->

  let not_handled_include_format () = 
    raise (UnrecognizedInclude 
              (spf  "unrecognized format of include/require at %s"
                  (Ast.string_of_info tok)));
  in
    
  match Ast.untype e with

  (* e.g.  $_SERVER['PHP_ROOT'] . '/lib/foo.php' *)
  | Binary (e1, 
           (BinaryConcat, _),
           e2) ->

      let base = 
        match Ast.untype e1 with
        | Lv
            (VArrayAccess
                ((Var (DName (varname, _), _scope), _t),
                (_tok,
                Some
                  (Sc (Ast.C (String (fieldname, _info))), _t2),
                _info2)),
            _t3)
          ->
            (match varname, fieldname with
            | "_SERVER", "PHP_ROOT" -> 
                ""

            | "GLOBALS", "SQLParserRoot" -> 
                "/lib/intern/third-party/SQL_Parser"
            | "GLOBALS", "PHPUnitDir" ->
                "/lib/intern/third-party/PHPUnit"
            | "GLOBALS", "XHPROF_LIB_ROOT" ->
                "/lib/prof/xhprof_lib"

            | "GLOBALS", "ConsoleCLIRoot" ->
                "/lib/intern/third-party/Console_CommandLine"
            | _ ->  not_handled_include_format ()
            )
        | _ -> not_handled_include_format ()
      in
      let rest = 
        match Ast.untype e2 with
        | Sc (Ast.C (String (str, _info))) ->
            str
        | _ ->  not_handled_include_format ()
      in
      base ^ rest
  | _ -> not_handled_include_format ()

  
(*****************************************************************************)
(* AST parsing and analysis *)
(*****************************************************************************)

let dependencies_file file = 

  let (ast2, _stat) = Parse_php.parse file in
  let ast = Parse_php.program_of_program2 ast2 in

  (* for the flib require_source() we need to know the flib relative path of
   * the currently processed file *)
  let flib_relative_path_file = 
    if file =~ ".*/flib/\\(.*\\)"
    then Common.matched1 file
    else ""
  in

  let includes = ref [] in
  let provides = ref [] in
  let depends = ref [] in 
  let thrift_autoload = ref [] in

  (* let's visit the ast *)
  let hooks = { V.default_visitor with
    
    (* provides *)
    V.kfunc_def = (fun (k, _) def ->
      k def;

      let sfunc = Ast.name def.f_name in
      let info = Ast.info_of_name def.f_name in
      Common.push2 ({
        e_kind = Function sfunc;
        e_pos = pos_of_info info;
      }) provides;
    );
    V.kclass_def = (fun (k, _) def ->
      k def;

      let sclass = Ast.name def.c_name in
      let info = Ast.info_of_name def.c_name in
      Common.push2 ({
        e_kind =  Class sclass;
        e_pos = pos_of_info info;
      }) provides;

      def.c_extends +> Common.do_option (fun (tok, classname) ->
        let sclass = Ast.name classname in
        let info = Ast.info_of_name classname in
        Common.push2 ({
          e_kind =  Class sclass;
          e_pos = pos_of_info info;
        }) depends;
        
      );
    );

    V.kexpr = (fun (k, bigf) x ->

      match Ast.untype x with

      | Require (tok, e) | RequireOnce (tok, e)
      | Include (tok, e) | IncludeOnce (tok, e) 
          ->
          (try 
              let final_path = 
                path_analysis e tok
              in
              Common.push2 (
                final_path, (pos_of_info tok)
              ) includes;
            with UnrecognizedInclude s ->
              pr2 s
          )


      | New (tok, classname_ref, _) 
      | AssignNew (_, _, _, tok, classname_ref, _) ->
          (match classname_ref with
          | ClassNameRefStatic classname -> 
              let sclass = Ast.name classname in
              let info = Ast.info_of_name classname in
              Common.push2 ({
                e_kind =  Class sclass;
                e_pos = pos_of_info info;
              }) depends;
  
          | ClassNameRefDynamic _ -> ()
          );
          k x

      (* e.g. $GLOBALS['THRIFT_AUTOLOAD']['foo'] = 'bar.php'; 
       * Pattern generated via:
       *   $ meta/ffi -dump_php_ml tests/dependencies/thrift.php 
       *)

      | Assign(
         (VArrayAccess(
            (VArrayAccess((Var(DName(("GLOBALS", i_1)), t), tlval_2),
               (i_3,
                Some((Sc(Ast.C(String(("THRIFT_AUTOLOAD", i_4)))), t_5)),
                i_6)),
             tlval_7),
            (i_8, Some((Sc(Ast.C(String((sclass, i_9)))), t_10)), i_11)),
          tlval_12), i_13,
         (Sc(Ast.C(String((sfile, info_file)))), t_15))

        -> 
          Common.push2 ({
            t_class = sclass;
            t_file = sfile;
            t_pos = pos_of_info info_file;
          }) thrift_autoload;
          k x

      | _ -> 
          k x
    );
          

    V.klvalue = (fun (k, _) v ->
      match Ast.untype v with
      | FunCallSimple (name, args) ->
          (* recurse *)
          k v;


          let sfunc = Ast.name name in
          let info = Ast.info_of_name name in
          
          (* could be a regular function call, or a require_module special
           * call *)
          
          (match sfunc, args +> Ast.unparen +> Ast.uncomma  with

          | "define",
              (Arg ((Sc (Ast.C (String (s,info)))), _t))::xs ->

              Common.push2 {
                e_kind = Constant s;
                e_pos = pos_of_info info;
              } provides;

          (* handling flib directives. see flib/__flib.php and the 
           * definitions of the require_xxx() to know their semantic 
           * and to which include directive they expand to.
           *)
          | ("require_module" | "require_module_lazy") ,
            [(Arg ((Sc (Ast.C (String (str,_))), _t1)))] ->
              Common.push2 (
                "/flib/" ^ str ^ "/__init__.php", pos_of_info info
              ) includes;

          | "require_source",
            [(Arg ((Sc (Ast.C (String (str,_))), _t1)))] ->

              (* dir, base, extension *)
              let (d,b,e) = 
                Common.dbe_of_filename_nodot flib_relative_path_file in
              
              Common.push2 (
                (* e.g. require_source('bar.php') in flib/a/__init__php 
                 * will add 'flib/a/bar.php' as an include dependency *)
                "/flib/" ^ d ^ "/" ^ str, pos_of_info info
              ) includes;


          | "require_conf",
            [(Arg ((Sc (Ast.C (String (str,_))), _t1)))] ->
              Common.push2 (
                "/conf/" ^ str, pos_of_info info
              ) includes;

          | "require_thrift_package",
            [(Arg ((Sc (Ast.C (String (str,_))), _)));
             (Arg ((Sc (Ast.C (String (str2,_))), _)))
            ] ->
              Common.push2 (
                spf "/lib/thrift/packages/%s/%s.php" str str2, 
                pos_of_info info
              ) includes;

          (* similar to regular include/require *)
          | "require_external_source", [(Arg e)] ->
              let final_path = 
                path_analysis e info
              in
              Common.push2 (
                final_path, pos_of_info info
              ) includes;
              
          | s, _ when s =~ "require_.*" -> 
              raise (UnrecognizedRequire
                        (spf "form of require not yet handled at: %s" 
                            (Ast.string_of_info info)))

          (* regular funcall, will be handled just below *)
          | _ -> ()
          );

          (* Now that we have processed the specialized case, we 
           * generate the dependency for the general case. That that
           * this will also add dependencies for the require_xxx() function
           * call itself.
           *)
          Common.push2 ({
            e_kind = Function sfunc;
            e_pos = pos_of_info info;
          }) depends;

      | _ ->  
          k v
    );

    V.kconstant = (fun (k, bigf) x ->
      match x with
      | CName name ->

          let s = Ast.name name in
          if not (List.mem s builtin_constants) then begin
            let info = Ast.info_of_name name in
            Common.push2 ({
              e_kind = Constant s;
              e_pos = pos_of_info info;
            }) depends;
          end
      | _ -> k x
          
    );
  }
  in
  let visitor = V.mk_visitor hooks in
  visitor.V.vprogram ast;

  { 
    includes = List.rev !includes;
    provides = List.rev !provides;
    depends = List.rev !depends;
    thrift_autoload = List.rev !thrift_autoload;
  }


(*****************************************************************************)
(* Main function *)
(*****************************************************************************)

let main = 
  let deps = dependencies_file Sys.argv.(1) in
  let json = json_of_deps deps in
  let s = Json_out.string_of_json json in
  pr s
